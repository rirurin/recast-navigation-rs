/* automatically generated by rust-bindgen 0.72.0 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub const NULL: u32 = 0;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type nullptr_t = *const ::std::os::raw::c_void;
    }
    pub type max_align_t = f64;
    #[doc = "< Memory persist after a function call."]
    pub const dtAllocHint_DT_ALLOC_PERM: dtAllocHint = 0;
    #[doc = "< Memory used temporarily within a function."]
    pub const dtAllocHint_DT_ALLOC_TEMP: dtAllocHint = 1;
    #[doc = " Provides hint values to the memory allocator on how long the\n memory is expected to be used."]
    pub type dtAllocHint = ::std::os::raw::c_int;
    #[doc = "  @see dtAllocSetCustom"]
    pub type dtAllocFunc = ::std::option::Option<
        unsafe extern "C" fn(size: usize, hint: root::dtAllocHint) -> *mut ::std::os::raw::c_void,
    >;
    #[doc = " A memory deallocation function.\n  @param[in]\t\tptr\t\tA pointer to a memory block previously allocated using #dtAllocFunc.\n @see dtAllocSetCustom"]
    pub type dtFreeFunc =
        ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>;
    unsafe extern "C" {
        #[doc = " Sets the base custom allocation functions to be used by Detour.\n  @param[in]\t\tallocFunc\tThe memory allocation function to be used by #dtAlloc\n  @param[in]\t\tfreeFunc\tThe memory de-allocation function to be used by #dtFree"]
        #[link_name = "\u{1}?dtAllocSetCustom@@YAXP6APEAX_KW4dtAllocHint@@@ZP6AXPEAX@Z@Z"]
        pub fn dtAllocSetCustom(allocFunc: root::dtAllocFunc, freeFunc: root::dtFreeFunc);
    }
    unsafe extern "C" {
        #[doc = " Allocates a memory block.\n  @param[in]\t\tsize\tThe size, in bytes of memory, to allocate.\n  @param[in]\t\thint\tA hint to the allocator on how long the memory is expected to be in use.\n  @return A pointer to the beginning of the allocated memory block, or null if the allocation failed.\n @see dtFree"]
        #[link_name = "\u{1}?dtAlloc@@YAPEAX_KW4dtAllocHint@@@Z"]
        pub fn dtAlloc(size: usize, hint: root::dtAllocHint) -> *mut ::std::os::raw::c_void;
    }
    unsafe extern "C" {
        #[doc = " Deallocates a memory block.\n  @param[in]\t\tptr\t\tA pointer to a memory block previously allocated using #dtAlloc.\n @see dtAlloc"]
        #[link_name = "\u{1}?dtFree@@YAXPEAX@Z"]
        pub fn dtFree(ptr: *mut ::std::os::raw::c_void);
    }
    pub type dtStatus = ::std::os::raw::c_uint;
    pub const DT_FAILURE: ::std::os::raw::c_uint = 2147483648;
    pub const DT_SUCCESS: ::std::os::raw::c_uint = 1073741824;
    pub const DT_IN_PROGRESS: ::std::os::raw::c_uint = 536870912;
    pub const DT_STATUS_DETAIL_MASK: ::std::os::raw::c_uint = 16777215;
    pub const DT_WRONG_MAGIC: ::std::os::raw::c_uint = 1;
    pub const DT_WRONG_VERSION: ::std::os::raw::c_uint = 2;
    pub const DT_OUT_OF_MEMORY: ::std::os::raw::c_uint = 4;
    pub const DT_INVALID_PARAM: ::std::os::raw::c_uint = 8;
    pub const DT_BUFFER_TOO_SMALL: ::std::os::raw::c_uint = 16;
    pub const DT_OUT_OF_NODES: ::std::os::raw::c_uint = 32;
    pub const DT_PARTIAL_RESULT: ::std::os::raw::c_uint = 64;
    pub const DT_ALREADY_OCCUPIED: ::std::os::raw::c_uint = 128;
    pub type dtPolyRef = ::std::os::raw::c_uint;
    pub type dtTileRef = ::std::os::raw::c_uint;
    #[doc = " The maximum number of vertices per navigation polygon.\n @ingroup detour"]
    pub const DT_VERTS_PER_POLYGON: ::std::os::raw::c_int = 6;
    #[doc = " A magic number used to detect compatibility of navigation tile data."]
    pub const DT_NAVMESH_MAGIC: ::std::os::raw::c_int = 1145979222;
    #[doc = " A version number used to detect compatibility of navigation tile data."]
    pub const DT_NAVMESH_VERSION: ::std::os::raw::c_int = 7;
    #[doc = " A magic number used to detect the compatibility of navigation tile states."]
    pub const DT_NAVMESH_STATE_MAGIC: ::std::os::raw::c_int = 1145982291;
    #[doc = " A version number used to detect compatibility of navigation tile states."]
    pub const DT_NAVMESH_STATE_VERSION: ::std::os::raw::c_int = 1;
    #[doc = " A flag that indicates that an entity links to an external entity.\n (E.g. A polygon edge is a portal that links to another polygon.)"]
    pub const DT_EXT_LINK: ::std::os::raw::c_ushort = 32768;
    #[doc = " A value that indicates the entity does not link to anything."]
    pub const DT_NULL_LINK: ::std::os::raw::c_uint = 4294967295;
    #[doc = " A flag that indicates that an off-mesh connection can be traversed in both directions. (Is bidirectional.)"]
    pub const DT_OFFMESH_CON_BIDIR: ::std::os::raw::c_uint = 1;
    #[doc = " The maximum number of user defined area ids.\n @ingroup detour"]
    pub const DT_MAX_AREAS: ::std::os::raw::c_int = 64;
    #[doc = " The navigation mesh owns the tile memory and is responsible for freeing it."]
    pub const dtTileFlags_DT_TILE_FREE_DATA: dtTileFlags = 1;
    #[doc = " Tile flags used for various functions and fields.\n For an example, see dtNavMesh::addTile()."]
    pub type dtTileFlags = ::std::os::raw::c_int;
    #[doc = "< The vertex is the start position in the path."]
    pub const dtStraightPathFlags_DT_STRAIGHTPATH_START: dtStraightPathFlags = 1;
    #[doc = "< The vertex is the end position in the path."]
    pub const dtStraightPathFlags_DT_STRAIGHTPATH_END: dtStraightPathFlags = 2;
    #[doc = "< The vertex is the start of an off-mesh connection."]
    pub const dtStraightPathFlags_DT_STRAIGHTPATH_OFFMESH_CONNECTION: dtStraightPathFlags = 4;
    #[doc = " Vertex flags returned by dtNavMeshQuery::findStraightPath."]
    pub type dtStraightPathFlags = ::std::os::raw::c_int;
    #[doc = "< Add a vertex at every polygon edge crossing where area changes."]
    pub const dtStraightPathOptions_DT_STRAIGHTPATH_AREA_CROSSINGS: dtStraightPathOptions = 1;
    #[doc = "< Add a vertex at every polygon edge crossing."]
    pub const dtStraightPathOptions_DT_STRAIGHTPATH_ALL_CROSSINGS: dtStraightPathOptions = 2;
    #[doc = " Options for dtNavMeshQuery::findStraightPath."]
    pub type dtStraightPathOptions = ::std::os::raw::c_int;
    #[doc = "< use raycasts during pathfind to \"shortcut\" (raycast still consider costs)"]
    pub const dtFindPathOptions_DT_FINDPATH_ANY_ANGLE: dtFindPathOptions = 2;
    #[doc = " Options for dtNavMeshQuery::initSlicedFindPath and updateSlicedFindPath"]
    pub type dtFindPathOptions = ::std::os::raw::c_int;
    #[doc = "< Raycast should calculate movement cost along the ray and fill RaycastHit::cost"]
    pub const dtRaycastOptions_DT_RAYCAST_USE_COSTS: dtRaycastOptions = 1;
    #[doc = " Options for dtNavMeshQuery::raycast"]
    pub type dtRaycastOptions = ::std::os::raw::c_int;
    #[doc = "< Detail triangle edge is part of the poly boundary"]
    pub const dtDetailTriEdgeFlags_DT_DETAIL_EDGE_BOUNDARY: dtDetailTriEdgeFlags = 1;
    pub type dtDetailTriEdgeFlags = ::std::os::raw::c_int;
    #[doc = " Limit raycasting during any angle pahfinding\n The limit is given as a multiple of the character radius"]
    pub const DT_RAY_CAST_LIMIT_PROPORTIONS: f32 = 50.0;
    #[doc = " The polygon is a standard convex polygon that is part of the surface of the mesh."]
    pub const dtPolyTypes_DT_POLYTYPE_GROUND: dtPolyTypes = 0;
    #[doc = " The polygon is an off-mesh connection consisting of two vertices."]
    pub const dtPolyTypes_DT_POLYTYPE_OFFMESH_CONNECTION: dtPolyTypes = 1;
    #[doc = " Flags representing the type of a navigation mesh polygon."]
    pub type dtPolyTypes = ::std::os::raw::c_int;
    #[doc = " Defines a polygon within a dtMeshTile object.\n @ingroup detour"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtPoly {
        #[doc = " Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)"]
        pub firstLink: ::std::os::raw::c_uint,
        #[doc = " The indices of the polygon's vertices.\n The actual vertices are located in dtMeshTile::verts."]
        pub verts: [::std::os::raw::c_ushort; 6usize],
        #[doc = " Packed data representing neighbor polygons references and flags for each edge."]
        pub neis: [::std::os::raw::c_ushort; 6usize],
        #[doc = " The user defined polygon flags."]
        pub flags: ::std::os::raw::c_ushort,
        #[doc = " The number of vertices in the polygon."]
        pub vertCount: ::std::os::raw::c_uchar,
        #[doc = " The bit packed area id and polygon type.\n @note Use the structure's set and get methods to access this value."]
        pub areaAndtype: ::std::os::raw::c_uchar,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtPoly"][::std::mem::size_of::<dtPoly>() - 32usize];
        ["Alignment of dtPoly"][::std::mem::align_of::<dtPoly>() - 4usize];
        ["Offset of field: dtPoly::firstLink"][::std::mem::offset_of!(dtPoly, firstLink) - 0usize];
        ["Offset of field: dtPoly::verts"][::std::mem::offset_of!(dtPoly, verts) - 4usize];
        ["Offset of field: dtPoly::neis"][::std::mem::offset_of!(dtPoly, neis) - 16usize];
        ["Offset of field: dtPoly::flags"][::std::mem::offset_of!(dtPoly, flags) - 28usize];
        ["Offset of field: dtPoly::vertCount"][::std::mem::offset_of!(dtPoly, vertCount) - 30usize];
        ["Offset of field: dtPoly::areaAndtype"]
            [::std::mem::offset_of!(dtPoly, areaAndtype) - 31usize];
    };
    #[doc = " Defines the location of detail sub-mesh data within a dtMeshTile."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtPolyDetail {
        #[doc = "< The offset of the vertices in the dtMeshTile::detailVerts array."]
        pub vertBase: ::std::os::raw::c_uint,
        #[doc = "< The offset of the triangles in the dtMeshTile::detailTris array."]
        pub triBase: ::std::os::raw::c_uint,
        #[doc = "< The number of vertices in the sub-mesh."]
        pub vertCount: ::std::os::raw::c_uchar,
        #[doc = "< The number of triangles in the sub-mesh."]
        pub triCount: ::std::os::raw::c_uchar,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtPolyDetail"][::std::mem::size_of::<dtPolyDetail>() - 12usize];
        ["Alignment of dtPolyDetail"][::std::mem::align_of::<dtPolyDetail>() - 4usize];
        ["Offset of field: dtPolyDetail::vertBase"]
            [::std::mem::offset_of!(dtPolyDetail, vertBase) - 0usize];
        ["Offset of field: dtPolyDetail::triBase"]
            [::std::mem::offset_of!(dtPolyDetail, triBase) - 4usize];
        ["Offset of field: dtPolyDetail::vertCount"]
            [::std::mem::offset_of!(dtPolyDetail, vertCount) - 8usize];
        ["Offset of field: dtPolyDetail::triCount"]
            [::std::mem::offset_of!(dtPolyDetail, triCount) - 9usize];
    };
    #[doc = " Defines a link between polygons.\n @note This structure is rarely if ever used by the end user.\n @see dtMeshTile"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtLink {
        #[doc = "< Neighbour reference. (The neighbor that is linked to.)"]
        pub ref_: root::dtPolyRef,
        #[doc = "< Index of the next link."]
        pub next: ::std::os::raw::c_uint,
        #[doc = "< Index of the polygon edge that owns this link."]
        pub edge: ::std::os::raw::c_uchar,
        #[doc = "< If a boundary link, defines on which side the link is."]
        pub side: ::std::os::raw::c_uchar,
        #[doc = "< If a boundary link, defines the minimum sub-edge area."]
        pub bmin: ::std::os::raw::c_uchar,
        #[doc = "< If a boundary link, defines the maximum sub-edge area."]
        pub bmax: ::std::os::raw::c_uchar,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtLink"][::std::mem::size_of::<dtLink>() - 12usize];
        ["Alignment of dtLink"][::std::mem::align_of::<dtLink>() - 4usize];
        ["Offset of field: dtLink::ref_"][::std::mem::offset_of!(dtLink, ref_) - 0usize];
        ["Offset of field: dtLink::next"][::std::mem::offset_of!(dtLink, next) - 4usize];
        ["Offset of field: dtLink::edge"][::std::mem::offset_of!(dtLink, edge) - 8usize];
        ["Offset of field: dtLink::side"][::std::mem::offset_of!(dtLink, side) - 9usize];
        ["Offset of field: dtLink::bmin"][::std::mem::offset_of!(dtLink, bmin) - 10usize];
        ["Offset of field: dtLink::bmax"][::std::mem::offset_of!(dtLink, bmax) - 11usize];
    };
    #[doc = " Bounding volume node.\n @note This structure is rarely if ever used by the end user.\n @see dtMeshTile"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtBVNode {
        #[doc = "< Minimum bounds of the node's AABB. [(x, y, z)]"]
        pub bmin: [::std::os::raw::c_ushort; 3usize],
        #[doc = "< Maximum bounds of the node's AABB. [(x, y, z)]"]
        pub bmax: [::std::os::raw::c_ushort; 3usize],
        #[doc = "< The node's index. (Negative for escape sequence.)"]
        pub i: ::std::os::raw::c_int,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtBVNode"][::std::mem::size_of::<dtBVNode>() - 16usize];
        ["Alignment of dtBVNode"][::std::mem::align_of::<dtBVNode>() - 4usize];
        ["Offset of field: dtBVNode::bmin"][::std::mem::offset_of!(dtBVNode, bmin) - 0usize];
        ["Offset of field: dtBVNode::bmax"][::std::mem::offset_of!(dtBVNode, bmax) - 6usize];
        ["Offset of field: dtBVNode::i"][::std::mem::offset_of!(dtBVNode, i) - 12usize];
    };
    #[doc = " Defines an navigation mesh off-mesh connection within a dtMeshTile object.\n An off-mesh connection is a user defined traversable connection made up to two vertices."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtOffMeshConnection {
        #[doc = " The endpoints of the connection. [(ax, ay, az, bx, by, bz)]"]
        pub pos: [f32; 6usize],
        #[doc = " The radius of the endpoints. [Limit: >= 0]"]
        pub rad: f32,
        #[doc = " The polygon reference of the connection within the tile."]
        pub poly: ::std::os::raw::c_ushort,
        #[doc = " Link flags.\n @note These are not the connection's user defined flags. Those are assigned via the\n connection's dtPoly definition. These are link flags used for internal purposes."]
        pub flags: ::std::os::raw::c_uchar,
        #[doc = " End point side."]
        pub side: ::std::os::raw::c_uchar,
        #[doc = " The id of the offmesh connection. (User assigned when the navigation mesh is built.)"]
        pub userId: ::std::os::raw::c_uint,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtOffMeshConnection"][::std::mem::size_of::<dtOffMeshConnection>() - 36usize];
        ["Alignment of dtOffMeshConnection"]
            [::std::mem::align_of::<dtOffMeshConnection>() - 4usize];
        ["Offset of field: dtOffMeshConnection::pos"]
            [::std::mem::offset_of!(dtOffMeshConnection, pos) - 0usize];
        ["Offset of field: dtOffMeshConnection::rad"]
            [::std::mem::offset_of!(dtOffMeshConnection, rad) - 24usize];
        ["Offset of field: dtOffMeshConnection::poly"]
            [::std::mem::offset_of!(dtOffMeshConnection, poly) - 28usize];
        ["Offset of field: dtOffMeshConnection::flags"]
            [::std::mem::offset_of!(dtOffMeshConnection, flags) - 30usize];
        ["Offset of field: dtOffMeshConnection::side"]
            [::std::mem::offset_of!(dtOffMeshConnection, side) - 31usize];
        ["Offset of field: dtOffMeshConnection::userId"]
            [::std::mem::offset_of!(dtOffMeshConnection, userId) - 32usize];
    };
    #[doc = " Provides high level information related to a dtMeshTile object.\n @ingroup detour"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtMeshHeader {
        #[doc = "< Tile magic number. (Used to identify the data format.)"]
        pub magic: ::std::os::raw::c_int,
        #[doc = "< Tile data format version number."]
        pub version: ::std::os::raw::c_int,
        #[doc = "< The x-position of the tile within the dtNavMesh tile grid. (x, y, layer)"]
        pub x: ::std::os::raw::c_int,
        #[doc = "< The y-position of the tile within the dtNavMesh tile grid. (x, y, layer)"]
        pub y: ::std::os::raw::c_int,
        #[doc = "< The layer of the tile within the dtNavMesh tile grid. (x, y, layer)"]
        pub layer: ::std::os::raw::c_int,
        #[doc = "< The user defined id of the tile."]
        pub userId: ::std::os::raw::c_uint,
        #[doc = "< The number of polygons in the tile."]
        pub polyCount: ::std::os::raw::c_int,
        #[doc = "< The number of vertices in the tile."]
        pub vertCount: ::std::os::raw::c_int,
        #[doc = "< The number of allocated links."]
        pub maxLinkCount: ::std::os::raw::c_int,
        #[doc = "< The number of sub-meshes in the detail mesh."]
        pub detailMeshCount: ::std::os::raw::c_int,
        #[doc = " The number of unique vertices in the detail mesh. (In addition to the polygon vertices.)"]
        pub detailVertCount: ::std::os::raw::c_int,
        #[doc = "< The number of triangles in the detail mesh."]
        pub detailTriCount: ::std::os::raw::c_int,
        #[doc = "< The number of bounding volume nodes. (Zero if bounding volumes are disabled.)"]
        pub bvNodeCount: ::std::os::raw::c_int,
        #[doc = "< The number of off-mesh connections."]
        pub offMeshConCount: ::std::os::raw::c_int,
        #[doc = "< The index of the first polygon which is an off-mesh connection."]
        pub offMeshBase: ::std::os::raw::c_int,
        #[doc = "< The height of the agents using the tile."]
        pub walkableHeight: f32,
        #[doc = "< The radius of the agents using the tile."]
        pub walkableRadius: f32,
        #[doc = "< The maximum climb height of the agents using the tile."]
        pub walkableClimb: f32,
        #[doc = "< The minimum bounds of the tile's AABB. [(x, y, z)]"]
        pub bmin: [f32; 3usize],
        #[doc = "< The maximum bounds of the tile's AABB. [(x, y, z)]"]
        pub bmax: [f32; 3usize],
        #[doc = " The bounding volume quantization factor."]
        pub bvQuantFactor: f32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtMeshHeader"][::std::mem::size_of::<dtMeshHeader>() - 100usize];
        ["Alignment of dtMeshHeader"][::std::mem::align_of::<dtMeshHeader>() - 4usize];
        ["Offset of field: dtMeshHeader::magic"]
            [::std::mem::offset_of!(dtMeshHeader, magic) - 0usize];
        ["Offset of field: dtMeshHeader::version"]
            [::std::mem::offset_of!(dtMeshHeader, version) - 4usize];
        ["Offset of field: dtMeshHeader::x"][::std::mem::offset_of!(dtMeshHeader, x) - 8usize];
        ["Offset of field: dtMeshHeader::y"][::std::mem::offset_of!(dtMeshHeader, y) - 12usize];
        ["Offset of field: dtMeshHeader::layer"]
            [::std::mem::offset_of!(dtMeshHeader, layer) - 16usize];
        ["Offset of field: dtMeshHeader::userId"]
            [::std::mem::offset_of!(dtMeshHeader, userId) - 20usize];
        ["Offset of field: dtMeshHeader::polyCount"]
            [::std::mem::offset_of!(dtMeshHeader, polyCount) - 24usize];
        ["Offset of field: dtMeshHeader::vertCount"]
            [::std::mem::offset_of!(dtMeshHeader, vertCount) - 28usize];
        ["Offset of field: dtMeshHeader::maxLinkCount"]
            [::std::mem::offset_of!(dtMeshHeader, maxLinkCount) - 32usize];
        ["Offset of field: dtMeshHeader::detailMeshCount"]
            [::std::mem::offset_of!(dtMeshHeader, detailMeshCount) - 36usize];
        ["Offset of field: dtMeshHeader::detailVertCount"]
            [::std::mem::offset_of!(dtMeshHeader, detailVertCount) - 40usize];
        ["Offset of field: dtMeshHeader::detailTriCount"]
            [::std::mem::offset_of!(dtMeshHeader, detailTriCount) - 44usize];
        ["Offset of field: dtMeshHeader::bvNodeCount"]
            [::std::mem::offset_of!(dtMeshHeader, bvNodeCount) - 48usize];
        ["Offset of field: dtMeshHeader::offMeshConCount"]
            [::std::mem::offset_of!(dtMeshHeader, offMeshConCount) - 52usize];
        ["Offset of field: dtMeshHeader::offMeshBase"]
            [::std::mem::offset_of!(dtMeshHeader, offMeshBase) - 56usize];
        ["Offset of field: dtMeshHeader::walkableHeight"]
            [::std::mem::offset_of!(dtMeshHeader, walkableHeight) - 60usize];
        ["Offset of field: dtMeshHeader::walkableRadius"]
            [::std::mem::offset_of!(dtMeshHeader, walkableRadius) - 64usize];
        ["Offset of field: dtMeshHeader::walkableClimb"]
            [::std::mem::offset_of!(dtMeshHeader, walkableClimb) - 68usize];
        ["Offset of field: dtMeshHeader::bmin"]
            [::std::mem::offset_of!(dtMeshHeader, bmin) - 72usize];
        ["Offset of field: dtMeshHeader::bmax"]
            [::std::mem::offset_of!(dtMeshHeader, bmax) - 84usize];
        ["Offset of field: dtMeshHeader::bvQuantFactor"]
            [::std::mem::offset_of!(dtMeshHeader, bvQuantFactor) - 96usize];
    };
    #[doc = " Defines a navigation mesh tile.\n @ingroup detour"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtMeshTile {
        #[doc = "< Counter describing modifications to the tile."]
        pub salt: ::std::os::raw::c_uint,
        #[doc = "< Index to the next free link."]
        pub linksFreeList: ::std::os::raw::c_uint,
        #[doc = "< The tile header."]
        pub header: *mut root::dtMeshHeader,
        #[doc = "< The tile polygons. [Size: dtMeshHeader::polyCount]"]
        pub polys: *mut root::dtPoly,
        #[doc = "< The tile vertices. [(x, y, z) * dtMeshHeader::vertCount]"]
        pub verts: *mut f32,
        #[doc = "< The tile links. [Size: dtMeshHeader::maxLinkCount]"]
        pub links: *mut root::dtLink,
        #[doc = "< The tile's detail sub-meshes. [Size: dtMeshHeader::detailMeshCount]"]
        pub detailMeshes: *mut root::dtPolyDetail,
        #[doc = " The detail mesh's unique vertices. [(x, y, z) * dtMeshHeader::detailVertCount]"]
        pub detailVerts: *mut f32,
        #[doc = " The detail mesh's triangles. [(vertA, vertB, vertC, triFlags) * dtMeshHeader::detailTriCount].\n See dtDetailTriEdgeFlags and dtGetDetailTriEdgeFlags."]
        pub detailTris: *mut ::std::os::raw::c_uchar,
        #[doc = " The tile bounding volume nodes. [Size: dtMeshHeader::bvNodeCount]\n (Will be null if bounding volumes are disabled.)"]
        pub bvTree: *mut root::dtBVNode,
        #[doc = "< The tile off-mesh connections. [Size: dtMeshHeader::offMeshConCount]"]
        pub offMeshCons: *mut root::dtOffMeshConnection,
        #[doc = "< The tile data. (Not directly accessed under normal situations.)"]
        pub data: *mut ::std::os::raw::c_uchar,
        #[doc = "< Size of the tile data."]
        pub dataSize: ::std::os::raw::c_int,
        #[doc = "< Tile flags. (See: #dtTileFlags)"]
        pub flags: ::std::os::raw::c_int,
        #[doc = "< The next free tile, or the next tile in the spatial grid."]
        pub next: *mut root::dtMeshTile,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtMeshTile"][::std::mem::size_of::<dtMeshTile>() - 104usize];
        ["Alignment of dtMeshTile"][::std::mem::align_of::<dtMeshTile>() - 8usize];
        ["Offset of field: dtMeshTile::salt"][::std::mem::offset_of!(dtMeshTile, salt) - 0usize];
        ["Offset of field: dtMeshTile::linksFreeList"]
            [::std::mem::offset_of!(dtMeshTile, linksFreeList) - 4usize];
        ["Offset of field: dtMeshTile::header"]
            [::std::mem::offset_of!(dtMeshTile, header) - 8usize];
        ["Offset of field: dtMeshTile::polys"][::std::mem::offset_of!(dtMeshTile, polys) - 16usize];
        ["Offset of field: dtMeshTile::verts"][::std::mem::offset_of!(dtMeshTile, verts) - 24usize];
        ["Offset of field: dtMeshTile::links"][::std::mem::offset_of!(dtMeshTile, links) - 32usize];
        ["Offset of field: dtMeshTile::detailMeshes"]
            [::std::mem::offset_of!(dtMeshTile, detailMeshes) - 40usize];
        ["Offset of field: dtMeshTile::detailVerts"]
            [::std::mem::offset_of!(dtMeshTile, detailVerts) - 48usize];
        ["Offset of field: dtMeshTile::detailTris"]
            [::std::mem::offset_of!(dtMeshTile, detailTris) - 56usize];
        ["Offset of field: dtMeshTile::bvTree"]
            [::std::mem::offset_of!(dtMeshTile, bvTree) - 64usize];
        ["Offset of field: dtMeshTile::offMeshCons"]
            [::std::mem::offset_of!(dtMeshTile, offMeshCons) - 72usize];
        ["Offset of field: dtMeshTile::data"][::std::mem::offset_of!(dtMeshTile, data) - 80usize];
        ["Offset of field: dtMeshTile::dataSize"]
            [::std::mem::offset_of!(dtMeshTile, dataSize) - 88usize];
        ["Offset of field: dtMeshTile::flags"][::std::mem::offset_of!(dtMeshTile, flags) - 92usize];
        ["Offset of field: dtMeshTile::next"][::std::mem::offset_of!(dtMeshTile, next) - 96usize];
    };
    #[doc = " Configuration parameters used to define multi-tile navigation meshes.\n The values are used to allocate space during the initialization of a navigation mesh.\n @see dtNavMesh::init()\n @ingroup detour"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtNavMeshParams {
        #[doc = "< The world space origin of the navigation mesh's tile space. [(x, y, z)]"]
        pub orig: [f32; 3usize],
        #[doc = "< The width of each tile. (Along the x-axis.)"]
        pub tileWidth: f32,
        #[doc = "< The height of each tile. (Along the z-axis.)"]
        pub tileHeight: f32,
        #[doc = "< The maximum number of tiles the navigation mesh can contain. This and maxPolys are used to calculate how many bits are needed to identify tiles and polygons uniquely."]
        pub maxTiles: ::std::os::raw::c_int,
        #[doc = "< The maximum number of polygons each tile can contain. This and maxTiles are used to calculate how many bits are needed to identify tiles and polygons uniquely."]
        pub maxPolys: ::std::os::raw::c_int,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtNavMeshParams"][::std::mem::size_of::<dtNavMeshParams>() - 28usize];
        ["Alignment of dtNavMeshParams"][::std::mem::align_of::<dtNavMeshParams>() - 4usize];
        ["Offset of field: dtNavMeshParams::orig"]
            [::std::mem::offset_of!(dtNavMeshParams, orig) - 0usize];
        ["Offset of field: dtNavMeshParams::tileWidth"]
            [::std::mem::offset_of!(dtNavMeshParams, tileWidth) - 12usize];
        ["Offset of field: dtNavMeshParams::tileHeight"]
            [::std::mem::offset_of!(dtNavMeshParams, tileHeight) - 16usize];
        ["Offset of field: dtNavMeshParams::maxTiles"]
            [::std::mem::offset_of!(dtNavMeshParams, maxTiles) - 20usize];
        ["Offset of field: dtNavMeshParams::maxPolys"]
            [::std::mem::offset_of!(dtNavMeshParams, maxPolys) - 24usize];
    };
    #[doc = " A navigation mesh based on tiles of convex polygons.\n @ingroup detour"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtNavMesh {
        #[doc = "< Current initialization params. TODO: do not store this info twice."]
        pub m_params: root::dtNavMeshParams,
        #[doc = "< Origin of the tile (0,0)"]
        pub m_orig: [f32; 3usize],
        #[doc = "< Dimensions of each tile."]
        pub m_tileWidth: f32,
        #[doc = "< Dimensions of each tile."]
        pub m_tileHeight: f32,
        #[doc = "< Max number of tiles."]
        pub m_maxTiles: ::std::os::raw::c_int,
        #[doc = "< Tile hash lookup size (must be pot)."]
        pub m_tileLutSize: ::std::os::raw::c_int,
        #[doc = "< Tile hash lookup mask."]
        pub m_tileLutMask: ::std::os::raw::c_int,
        #[doc = "< Tile hash lookup."]
        pub m_posLookup: *mut *mut root::dtMeshTile,
        #[doc = "< Freelist of tiles."]
        pub m_nextFree: *mut root::dtMeshTile,
        #[doc = "< List of tiles."]
        pub m_tiles: *mut root::dtMeshTile,
        #[doc = "< Number of salt bits in the tile ID."]
        pub m_saltBits: ::std::os::raw::c_uint,
        #[doc = "< Number of tile bits in the tile ID."]
        pub m_tileBits: ::std::os::raw::c_uint,
        #[doc = "< Number of poly bits in the tile ID."]
        pub m_polyBits: ::std::os::raw::c_uint,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtNavMesh"][::std::mem::size_of::<dtNavMesh>() - 104usize];
        ["Alignment of dtNavMesh"][::std::mem::align_of::<dtNavMesh>() - 8usize];
        ["Offset of field: dtNavMesh::m_params"]
            [::std::mem::offset_of!(dtNavMesh, m_params) - 0usize];
        ["Offset of field: dtNavMesh::m_orig"][::std::mem::offset_of!(dtNavMesh, m_orig) - 28usize];
        ["Offset of field: dtNavMesh::m_tileWidth"]
            [::std::mem::offset_of!(dtNavMesh, m_tileWidth) - 40usize];
        ["Offset of field: dtNavMesh::m_tileHeight"]
            [::std::mem::offset_of!(dtNavMesh, m_tileHeight) - 44usize];
        ["Offset of field: dtNavMesh::m_maxTiles"]
            [::std::mem::offset_of!(dtNavMesh, m_maxTiles) - 48usize];
        ["Offset of field: dtNavMesh::m_tileLutSize"]
            [::std::mem::offset_of!(dtNavMesh, m_tileLutSize) - 52usize];
        ["Offset of field: dtNavMesh::m_tileLutMask"]
            [::std::mem::offset_of!(dtNavMesh, m_tileLutMask) - 56usize];
        ["Offset of field: dtNavMesh::m_posLookup"]
            [::std::mem::offset_of!(dtNavMesh, m_posLookup) - 64usize];
        ["Offset of field: dtNavMesh::m_nextFree"]
            [::std::mem::offset_of!(dtNavMesh, m_nextFree) - 72usize];
        ["Offset of field: dtNavMesh::m_tiles"]
            [::std::mem::offset_of!(dtNavMesh, m_tiles) - 80usize];
        ["Offset of field: dtNavMesh::m_saltBits"]
            [::std::mem::offset_of!(dtNavMesh, m_saltBits) - 88usize];
        ["Offset of field: dtNavMesh::m_tileBits"]
            [::std::mem::offset_of!(dtNavMesh, m_tileBits) - 92usize];
        ["Offset of field: dtNavMesh::m_polyBits"]
            [::std::mem::offset_of!(dtNavMesh, m_polyBits) - 96usize];
    };
    unsafe extern "C" {
        #[doc = " Initializes the navigation mesh for tiled use.\n  @param[in]\tparams\t\tInitialization parameters.\n @return The status flags for the operation."]
        #[link_name = "\u{1}?init@dtNavMesh@@QEAAIPEBUdtNavMeshParams@@@Z"]
        pub fn dtNavMesh_init(
            this: *mut root::dtNavMesh,
            params: *const root::dtNavMeshParams,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Initializes the navigation mesh for single tile use.\n  @param[in]\tdata\t\tData of the new tile. (See: #dtCreateNavMeshData)\n  @param[in]\tdataSize\tThe data size of the new tile.\n  @param[in]\tflags\t\tThe tile flags. (See: #dtTileFlags)\n @return The status flags for the operation.\n  @see dtCreateNavMeshData"]
        #[link_name = "\u{1}?init@dtNavMesh@@QEAAIPEAEHH@Z"]
        pub fn dtNavMesh_init1(
            this: *mut root::dtNavMesh,
            data: *mut ::std::os::raw::c_uchar,
            dataSize: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " The navigation mesh initialization params."]
        #[link_name = "\u{1}?getParams@dtNavMesh@@QEBAPEBUdtNavMeshParams@@XZ"]
        pub fn dtNavMesh_getParams(this: *const root::dtNavMesh) -> *const root::dtNavMeshParams;
    }
    unsafe extern "C" {
        #[doc = " Adds a tile to the navigation mesh.\n  @param[in]\t\tdata\t\tData for the new tile mesh. (See: #dtCreateNavMeshData)\n  @param[in]\t\tdataSize\tData size of the new tile mesh.\n  @param[in]\t\tflags\t\tTile flags. (See: #dtTileFlags)\n  @param[in]\t\tlastRef\t\tThe desired reference for the tile. (When reloading a tile.) [opt] [Default: 0]\n  @param[out]\tresult\t\tThe tile reference. (If the tile was succesfully added.) [opt]\n @return The status flags for the operation."]
        #[link_name = "\u{1}?addTile@dtNavMesh@@QEAAIPEAEHHIPEAI@Z"]
        pub fn dtNavMesh_addTile(
            this: *mut root::dtNavMesh,
            data: *mut ::std::os::raw::c_uchar,
            dataSize: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
            lastRef: root::dtTileRef,
            result: *mut root::dtTileRef,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Removes the specified tile from the navigation mesh.\n  @param[in]\t\tref\t\t\tThe reference of the tile to remove.\n  @param[out]\tdata\t\tData associated with deleted tile.\n  @param[out]\tdataSize\tSize of the data associated with deleted tile.\n @return The status flags for the operation."]
        #[link_name = "\u{1}?removeTile@dtNavMesh@@QEAAIIPEAPEAEPEAH@Z"]
        pub fn dtNavMesh_removeTile(
            this: *mut root::dtNavMesh,
            ref_: root::dtTileRef,
            data: *mut *mut ::std::os::raw::c_uchar,
            dataSize: *mut ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Calculates the tile grid location for the specified world position.\n  @param[in]\tpos  The world position for the query. [(x, y, z)]\n  @param[out]\ttx\t\tThe tile's x-location. (x, y)\n  @param[out]\tty\t\tThe tile's y-location. (x, y)"]
        #[link_name = "\u{1}?calcTileLoc@dtNavMesh@@QEBAXPEBMPEAH1@Z"]
        pub fn dtNavMesh_calcTileLoc(
            this: *const root::dtNavMesh,
            pos: *const f32,
            tx: *mut ::std::os::raw::c_int,
            ty: *mut ::std::os::raw::c_int,
        );
    }
    unsafe extern "C" {
        #[doc = " Gets the tile at the specified grid location.\n  @param[in]\tx\t\tThe tile's x-location. (x, y, layer)\n  @param[in]\ty\t\tThe tile's y-location. (x, y, layer)\n  @param[in]\tlayer\tThe tile's layer. (x, y, layer)\n @return The tile, or null if the tile does not exist."]
        #[link_name = "\u{1}?getTileAt@dtNavMesh@@QEBAPEBUdtMeshTile@@HHH@Z"]
        pub fn dtNavMesh_getTileAt(
            this: *const root::dtNavMesh,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            layer: ::std::os::raw::c_int,
        ) -> *const root::dtMeshTile;
    }
    unsafe extern "C" {
        #[doc = " Gets all tiles at the specified grid location. (All layers.)\n  @param[in]\t\tx\t\t\tThe tile's x-location. (x, y)\n  @param[in]\t\ty\t\t\tThe tile's y-location. (x, y)\n  @param[out]\ttiles\t\tA pointer to an array of tiles that will hold the result.\n  @param[in]\t\tmaxTiles\tThe maximum tiles the tiles parameter can hold.\n @return The number of tiles returned in the tiles array."]
        #[link_name = "\u{1}?getTilesAt@dtNavMesh@@QEBAHHHPEAPEBUdtMeshTile@@H@Z"]
        pub fn dtNavMesh_getTilesAt(
            this: *const root::dtNavMesh,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            tiles: *mut *const root::dtMeshTile,
            maxTiles: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[doc = " Gets the tile reference for the tile at specified grid location.\n  @param[in]\tx\t\tThe tile's x-location. (x, y, layer)\n  @param[in]\ty\t\tThe tile's y-location. (x, y, layer)\n  @param[in]\tlayer\tThe tile's layer. (x, y, layer)\n @return The tile reference of the tile, or 0 if there is none."]
        #[link_name = "\u{1}?getTileRefAt@dtNavMesh@@QEBAIHHH@Z"]
        pub fn dtNavMesh_getTileRefAt(
            this: *const root::dtNavMesh,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            layer: ::std::os::raw::c_int,
        ) -> root::dtTileRef;
    }
    unsafe extern "C" {
        #[doc = " Gets the tile reference for the specified tile.\n  @param[in]\ttile\tThe tile.\n @return The tile reference of the tile."]
        #[link_name = "\u{1}?getTileRef@dtNavMesh@@QEBAIPEBUdtMeshTile@@@Z"]
        pub fn dtNavMesh_getTileRef(
            this: *const root::dtNavMesh,
            tile: *const root::dtMeshTile,
        ) -> root::dtTileRef;
    }
    unsafe extern "C" {
        #[doc = " Gets the tile for the specified tile reference.\n  @param[in]\tref\t\tThe tile reference of the tile to retrieve.\n @return The tile for the specified reference, or null if the\n\t\treference is invalid."]
        #[link_name = "\u{1}?getTileByRef@dtNavMesh@@QEBAPEBUdtMeshTile@@I@Z"]
        pub fn dtNavMesh_getTileByRef(
            this: *const root::dtNavMesh,
            ref_: root::dtTileRef,
        ) -> *const root::dtMeshTile;
    }
    unsafe extern "C" {
        #[doc = " The maximum number of tiles supported by the navigation mesh.\n @return The maximum number of tiles supported by the navigation mesh."]
        #[link_name = "\u{1}?getMaxTiles@dtNavMesh@@QEBAHXZ"]
        pub fn dtNavMesh_getMaxTiles(this: *const root::dtNavMesh) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[doc = " Gets the tile at the specified index.\n  @param[in]\ti\t\tThe tile index. [Limit: 0 >= index < #getMaxTiles()]\n @return The tile at the specified index."]
        #[link_name = "\u{1}?getTile@dtNavMesh@@QEBAPEBUdtMeshTile@@H@Z"]
        pub fn dtNavMesh_getTile(
            this: *const root::dtNavMesh,
            i: ::std::os::raw::c_int,
        ) -> *const root::dtMeshTile;
    }
    unsafe extern "C" {
        #[doc = " Gets the tile and polygon for the specified polygon reference.\n  @param[in]\t\tref\t\tThe reference for the a polygon.\n  @param[out]\ttile\tThe tile containing the polygon.\n  @param[out]\tpoly\tThe polygon.\n @return The status flags for the operation."]
        #[link_name = "\u{1}?getTileAndPolyByRef@dtNavMesh@@QEBAIIPEAPEBUdtMeshTile@@PEAPEBUdtPoly@@@Z"]
        pub fn dtNavMesh_getTileAndPolyByRef(
            this: *const root::dtNavMesh,
            ref_: root::dtPolyRef,
            tile: *mut *const root::dtMeshTile,
            poly: *mut *const root::dtPoly,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Returns the tile and polygon for the specified polygon reference.\n  @param[in]\t\tref\t\tA known valid reference for a polygon.\n  @param[out]\ttile\tThe tile containing the polygon.\n  @param[out]\tpoly\tThe polygon."]
        #[link_name = "\u{1}?getTileAndPolyByRefUnsafe@dtNavMesh@@QEBAXIPEAPEBUdtMeshTile@@PEAPEBUdtPoly@@@Z"]
        pub fn dtNavMesh_getTileAndPolyByRefUnsafe(
            this: *const root::dtNavMesh,
            ref_: root::dtPolyRef,
            tile: *mut *const root::dtMeshTile,
            poly: *mut *const root::dtPoly,
        );
    }
    unsafe extern "C" {
        #[doc = " Checks the validity of a polygon reference.\n  @param[in]\tref\t\tThe polygon reference to check.\n @return True if polygon reference is valid for the navigation mesh."]
        #[link_name = "\u{1}?isValidPolyRef@dtNavMesh@@QEBA_NI@Z"]
        pub fn dtNavMesh_isValidPolyRef(
            this: *const root::dtNavMesh,
            ref_: root::dtPolyRef,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Gets the polygon reference for the tile's base polygon.\n  @param[in]\ttile\t\tThe tile.\n @return The polygon reference for the base polygon in the specified tile."]
        #[link_name = "\u{1}?getPolyRefBase@dtNavMesh@@QEBAIPEBUdtMeshTile@@@Z"]
        pub fn dtNavMesh_getPolyRefBase(
            this: *const root::dtNavMesh,
            tile: *const root::dtMeshTile,
        ) -> root::dtPolyRef;
    }
    unsafe extern "C" {
        #[doc = " Gets the endpoints for an off-mesh connection, ordered by \"direction of travel\".\n  @param[in]\t\tprevRef\t\tThe reference of the polygon before the connection.\n  @param[in]\t\tpolyRef\t\tThe reference of the off-mesh connection polygon.\n  @param[out]\tstartPos\tThe start position of the off-mesh connection. [(x, y, z)]\n  @param[out]\tendPos\t\tThe end position of the off-mesh connection. [(x, y, z)]\n @return The status flags for the operation."]
        #[link_name = "\u{1}?getOffMeshConnectionPolyEndPoints@dtNavMesh@@QEBAIIIPEAM0@Z"]
        pub fn dtNavMesh_getOffMeshConnectionPolyEndPoints(
            this: *const root::dtNavMesh,
            prevRef: root::dtPolyRef,
            polyRef: root::dtPolyRef,
            startPos: *mut f32,
            endPos: *mut f32,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Gets the specified off-mesh connection.\n  @param[in]\tref\t\tThe polygon reference of the off-mesh connection.\n @return The specified off-mesh connection, or null if the polygon reference is not valid."]
        #[link_name = "\u{1}?getOffMeshConnectionByRef@dtNavMesh@@QEBAPEBUdtOffMeshConnection@@I@Z"]
        pub fn dtNavMesh_getOffMeshConnectionByRef(
            this: *const root::dtNavMesh,
            ref_: root::dtPolyRef,
        ) -> *const root::dtOffMeshConnection;
    }
    unsafe extern "C" {
        #[doc = " Sets the user defined flags for the specified polygon.\n  @param[in]\tref\t\tThe polygon reference.\n  @param[in]\tflags\tThe new flags for the polygon.\n @return The status flags for the operation."]
        #[link_name = "\u{1}?setPolyFlags@dtNavMesh@@QEAAIIG@Z"]
        pub fn dtNavMesh_setPolyFlags(
            this: *mut root::dtNavMesh,
            ref_: root::dtPolyRef,
            flags: ::std::os::raw::c_ushort,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Gets the user defined flags for the specified polygon.\n  @param[in]\t\tref\t\t\t\tThe polygon reference.\n  @param[out]\tresultFlags\t\tThe polygon flags.\n @return The status flags for the operation."]
        #[link_name = "\u{1}?getPolyFlags@dtNavMesh@@QEBAIIPEAG@Z"]
        pub fn dtNavMesh_getPolyFlags(
            this: *const root::dtNavMesh,
            ref_: root::dtPolyRef,
            resultFlags: *mut ::std::os::raw::c_ushort,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Sets the user defined area for the specified polygon.\n  @param[in]\tref\t\tThe polygon reference.\n  @param[in]\tarea\tThe new area id for the polygon. [Limit: < #DT_MAX_AREAS]\n @return The status flags for the operation."]
        #[link_name = "\u{1}?setPolyArea@dtNavMesh@@QEAAIIE@Z"]
        pub fn dtNavMesh_setPolyArea(
            this: *mut root::dtNavMesh,
            ref_: root::dtPolyRef,
            area: ::std::os::raw::c_uchar,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Gets the user defined area for the specified polygon.\n  @param[in]\t\tref\t\t\tThe polygon reference.\n  @param[out]\tresultArea\tThe area id for the polygon.\n @return The status flags for the operation."]
        #[link_name = "\u{1}?getPolyArea@dtNavMesh@@QEBAIIPEAE@Z"]
        pub fn dtNavMesh_getPolyArea(
            this: *const root::dtNavMesh,
            ref_: root::dtPolyRef,
            resultArea: *mut ::std::os::raw::c_uchar,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Gets the size of the buffer required by #storeTileState to store the specified tile's state.\n  @param[in]\ttile\tThe tile.\n @return The size of the buffer required to store the state."]
        #[link_name = "\u{1}?getTileStateSize@dtNavMesh@@QEBAHPEBUdtMeshTile@@@Z"]
        pub fn dtNavMesh_getTileStateSize(
            this: *const root::dtNavMesh,
            tile: *const root::dtMeshTile,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[doc = " Stores the non-structural state of the tile in the specified buffer. (Flags, area ids, etc.)\n  @param[in]\t\ttile\t\t\tThe tile.\n  @param[out]\tdata\t\t\tThe buffer to store the tile's state in.\n  @param[in]\t\tmaxDataSize\t\tThe size of the data buffer. [Limit: >= #getTileStateSize]\n @return The status flags for the operation."]
        #[link_name = "\u{1}?storeTileState@dtNavMesh@@QEBAIPEBUdtMeshTile@@PEAEH@Z"]
        pub fn dtNavMesh_storeTileState(
            this: *const root::dtNavMesh,
            tile: *const root::dtMeshTile,
            data: *mut ::std::os::raw::c_uchar,
            maxDataSize: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Restores the state of the tile.\n  @param[in]\ttile\t\t\tThe tile.\n  @param[in]\tdata\t\t\tThe new state. (Obtained from #storeTileState.)\n  @param[in]\tmaxDataSize\t\tThe size of the state within the data buffer.\n @return The status flags for the operation."]
        #[link_name = "\u{1}?restoreTileState@dtNavMesh@@QEAAIPEAUdtMeshTile@@PEBEH@Z"]
        pub fn dtNavMesh_restoreTileState(
            this: *mut root::dtNavMesh,
            tile: *mut root::dtMeshTile,
            data: *const ::std::os::raw::c_uchar,
            maxDataSize: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtNavMesh@@QEAA@XZ"]
        pub fn dtNavMesh_dtNavMesh(this: *mut root::dtNavMesh);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtNavMesh@@QEAA@XZ"]
        pub fn dtNavMesh_dtNavMesh_destructor(this: *mut root::dtNavMesh);
    }
    impl dtNavMesh {
        #[inline]
        pub unsafe fn init(&mut self, params: *const root::dtNavMeshParams) -> root::dtStatus {
            dtNavMesh_init(self, params)
        }
        #[inline]
        pub unsafe fn init1(
            &mut self,
            data: *mut ::std::os::raw::c_uchar,
            dataSize: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMesh_init1(self, data, dataSize, flags)
        }
        #[inline]
        pub unsafe fn getParams(&self) -> *const root::dtNavMeshParams {
            dtNavMesh_getParams(self)
        }
        #[inline]
        pub unsafe fn addTile(
            &mut self,
            data: *mut ::std::os::raw::c_uchar,
            dataSize: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
            lastRef: root::dtTileRef,
            result: *mut root::dtTileRef,
        ) -> root::dtStatus {
            dtNavMesh_addTile(self, data, dataSize, flags, lastRef, result)
        }
        #[inline]
        pub unsafe fn removeTile(
            &mut self,
            ref_: root::dtTileRef,
            data: *mut *mut ::std::os::raw::c_uchar,
            dataSize: *mut ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMesh_removeTile(self, ref_, data, dataSize)
        }
        #[inline]
        pub unsafe fn calcTileLoc(
            &self,
            pos: *const f32,
            tx: *mut ::std::os::raw::c_int,
            ty: *mut ::std::os::raw::c_int,
        ) {
            dtNavMesh_calcTileLoc(self, pos, tx, ty)
        }
        #[inline]
        pub unsafe fn getTileAt(
            &self,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            layer: ::std::os::raw::c_int,
        ) -> *const root::dtMeshTile {
            dtNavMesh_getTileAt(self, x, y, layer)
        }
        #[inline]
        pub unsafe fn getTilesAt(
            &self,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            tiles: *mut *const root::dtMeshTile,
            maxTiles: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            dtNavMesh_getTilesAt(self, x, y, tiles, maxTiles)
        }
        #[inline]
        pub unsafe fn getTileRefAt(
            &self,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            layer: ::std::os::raw::c_int,
        ) -> root::dtTileRef {
            dtNavMesh_getTileRefAt(self, x, y, layer)
        }
        #[inline]
        pub unsafe fn getTileRef(&self, tile: *const root::dtMeshTile) -> root::dtTileRef {
            dtNavMesh_getTileRef(self, tile)
        }
        #[inline]
        pub unsafe fn getTileByRef(&self, ref_: root::dtTileRef) -> *const root::dtMeshTile {
            dtNavMesh_getTileByRef(self, ref_)
        }
        #[inline]
        pub unsafe fn getMaxTiles(&self) -> ::std::os::raw::c_int {
            dtNavMesh_getMaxTiles(self)
        }
        #[inline]
        pub unsafe fn getTile(&self, i: ::std::os::raw::c_int) -> *const root::dtMeshTile {
            dtNavMesh_getTile(self, i)
        }
        #[inline]
        pub unsafe fn getTileAndPolyByRef(
            &self,
            ref_: root::dtPolyRef,
            tile: *mut *const root::dtMeshTile,
            poly: *mut *const root::dtPoly,
        ) -> root::dtStatus {
            dtNavMesh_getTileAndPolyByRef(self, ref_, tile, poly)
        }
        #[inline]
        pub unsafe fn getTileAndPolyByRefUnsafe(
            &self,
            ref_: root::dtPolyRef,
            tile: *mut *const root::dtMeshTile,
            poly: *mut *const root::dtPoly,
        ) {
            dtNavMesh_getTileAndPolyByRefUnsafe(self, ref_, tile, poly)
        }
        #[inline]
        pub unsafe fn isValidPolyRef(&self, ref_: root::dtPolyRef) -> bool {
            dtNavMesh_isValidPolyRef(self, ref_)
        }
        #[inline]
        pub unsafe fn getPolyRefBase(&self, tile: *const root::dtMeshTile) -> root::dtPolyRef {
            dtNavMesh_getPolyRefBase(self, tile)
        }
        #[inline]
        pub unsafe fn getOffMeshConnectionPolyEndPoints(
            &self,
            prevRef: root::dtPolyRef,
            polyRef: root::dtPolyRef,
            startPos: *mut f32,
            endPos: *mut f32,
        ) -> root::dtStatus {
            dtNavMesh_getOffMeshConnectionPolyEndPoints(self, prevRef, polyRef, startPos, endPos)
        }
        #[inline]
        pub unsafe fn getOffMeshConnectionByRef(
            &self,
            ref_: root::dtPolyRef,
        ) -> *const root::dtOffMeshConnection {
            dtNavMesh_getOffMeshConnectionByRef(self, ref_)
        }
        #[inline]
        pub unsafe fn setPolyFlags(
            &mut self,
            ref_: root::dtPolyRef,
            flags: ::std::os::raw::c_ushort,
        ) -> root::dtStatus {
            dtNavMesh_setPolyFlags(self, ref_, flags)
        }
        #[inline]
        pub unsafe fn getPolyFlags(
            &self,
            ref_: root::dtPolyRef,
            resultFlags: *mut ::std::os::raw::c_ushort,
        ) -> root::dtStatus {
            dtNavMesh_getPolyFlags(self, ref_, resultFlags)
        }
        #[inline]
        pub unsafe fn setPolyArea(
            &mut self,
            ref_: root::dtPolyRef,
            area: ::std::os::raw::c_uchar,
        ) -> root::dtStatus {
            dtNavMesh_setPolyArea(self, ref_, area)
        }
        #[inline]
        pub unsafe fn getPolyArea(
            &self,
            ref_: root::dtPolyRef,
            resultArea: *mut ::std::os::raw::c_uchar,
        ) -> root::dtStatus {
            dtNavMesh_getPolyArea(self, ref_, resultArea)
        }
        #[inline]
        pub unsafe fn getTileStateSize(
            &self,
            tile: *const root::dtMeshTile,
        ) -> ::std::os::raw::c_int {
            dtNavMesh_getTileStateSize(self, tile)
        }
        #[inline]
        pub unsafe fn storeTileState(
            &self,
            tile: *const root::dtMeshTile,
            data: *mut ::std::os::raw::c_uchar,
            maxDataSize: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMesh_storeTileState(self, tile, data, maxDataSize)
        }
        #[inline]
        pub unsafe fn restoreTileState(
            &mut self,
            tile: *mut root::dtMeshTile,
            data: *const ::std::os::raw::c_uchar,
            maxDataSize: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMesh_restoreTileState(self, tile, data, maxDataSize)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtNavMesh_dtNavMesh(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            dtNavMesh_dtNavMesh_destructor(self)
        }
    }
    unsafe extern "C" {
        #[doc = " Allocates a navigation mesh object using the Detour allocator.\n @return A navigation mesh that is ready for initialization, or null on failure.\n  @ingroup detour"]
        #[link_name = "\u{1}?dtAllocNavMesh@@YAPEAVdtNavMesh@@XZ"]
        pub fn dtAllocNavMesh() -> *mut root::dtNavMesh;
    }
    unsafe extern "C" {
        #[doc = " Frees the specified navigation mesh object using the Detour allocator.\n  @param[in]\tnavmesh\t\tA navigation mesh allocated using #dtAllocNavMesh\n  @ingroup detour"]
        #[link_name = "\u{1}?dtFreeNavMesh@@YAXPEAVdtNavMesh@@@Z"]
        pub fn dtFreeNavMesh(navmesh: *mut root::dtNavMesh);
    }
    #[doc = " Represents the source data used to build an navigation mesh tile.\n @ingroup detour"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtNavMeshCreateParams {
        #[doc = "< The polygon mesh vertices. [(x, y, z) * #vertCount] [Unit: vx]"]
        pub verts: *const ::std::os::raw::c_ushort,
        #[doc = "< The number vertices in the polygon mesh. [Limit: >= 3]"]
        pub vertCount: ::std::os::raw::c_int,
        #[doc = "< The polygon data. [Size: #polyCount * 2 * #nvp]"]
        pub polys: *const ::std::os::raw::c_ushort,
        #[doc = "< The user defined flags assigned to each polygon. [Size: #polyCount]"]
        pub polyFlags: *const ::std::os::raw::c_ushort,
        #[doc = "< The user defined area ids assigned to each polygon. [Size: #polyCount]"]
        pub polyAreas: *const ::std::os::raw::c_uchar,
        #[doc = "< Number of polygons in the mesh. [Limit: >= 1]"]
        pub polyCount: ::std::os::raw::c_int,
        #[doc = "< Number maximum number of vertices per polygon. [Limit: >= 3]"]
        pub nvp: ::std::os::raw::c_int,
        #[doc = "< The height detail sub-mesh data. [Size: 4 * #polyCount]"]
        pub detailMeshes: *const ::std::os::raw::c_uint,
        #[doc = "< The detail mesh vertices. [Size: 3 * #detailVertsCount] [Unit: wu]"]
        pub detailVerts: *const f32,
        #[doc = "< The number of vertices in the detail mesh."]
        pub detailVertsCount: ::std::os::raw::c_int,
        #[doc = "< The detail mesh triangles. [Size: 4 * #detailTriCount]"]
        pub detailTris: *const ::std::os::raw::c_uchar,
        #[doc = "< The number of triangles in the detail mesh."]
        pub detailTriCount: ::std::os::raw::c_int,
        #[doc = " Off-mesh connection vertices. [(ax, ay, az, bx, by, bz) * #offMeshConCount] [Unit: wu]"]
        pub offMeshConVerts: *const f32,
        #[doc = " Off-mesh connection radii. [Size: #offMeshConCount] [Unit: wu]"]
        pub offMeshConRad: *const f32,
        #[doc = " User defined flags assigned to the off-mesh connections. [Size: #offMeshConCount]"]
        pub offMeshConFlags: *const ::std::os::raw::c_ushort,
        #[doc = " User defined area ids assigned to the off-mesh connections. [Size: #offMeshConCount]"]
        pub offMeshConAreas: *const ::std::os::raw::c_uchar,
        #[doc = " The permitted travel direction of the off-mesh connections. [Size: #offMeshConCount]\n\n 0 = Travel only from endpoint A to endpoint B.<br/>\n #DT_OFFMESH_CON_BIDIR = Bidirectional travel."]
        pub offMeshConDir: *const ::std::os::raw::c_uchar,
        #[doc = " The user defined ids of the off-mesh connection. [Size: #offMeshConCount]"]
        pub offMeshConUserID: *const ::std::os::raw::c_uint,
        #[doc = " The number of off-mesh connections. [Limit: >= 0]"]
        pub offMeshConCount: ::std::os::raw::c_int,
        #[doc = "< The user defined id of the tile."]
        pub userId: ::std::os::raw::c_uint,
        #[doc = "< The tile's x-grid location within the multi-tile destination mesh. (Along the x-axis.)"]
        pub tileX: ::std::os::raw::c_int,
        #[doc = "< The tile's y-grid location within the multi-tile destination mesh. (Along the z-axis.)"]
        pub tileY: ::std::os::raw::c_int,
        #[doc = "< The tile's layer within the layered destination mesh. [Limit: >= 0] (Along the y-axis.)"]
        pub tileLayer: ::std::os::raw::c_int,
        #[doc = "< The minimum bounds of the tile. [(x, y, z)] [Unit: wu]"]
        pub bmin: [f32; 3usize],
        #[doc = "< The maximum bounds of the tile. [(x, y, z)] [Unit: wu]"]
        pub bmax: [f32; 3usize],
        #[doc = "< The agent height. [Unit: wu]"]
        pub walkableHeight: f32,
        #[doc = "< The agent radius. [Unit: wu]"]
        pub walkableRadius: f32,
        #[doc = "< The agent maximum traversable ledge. (Up/Down) [Unit: wu]"]
        pub walkableClimb: f32,
        #[doc = "< The xz-plane cell size of the polygon mesh. [Limit: > 0] [Unit: wu]"]
        pub cs: f32,
        #[doc = "< The y-axis cell height of the polygon mesh. [Limit: > 0] [Unit: wu]"]
        pub ch: f32,
        #[doc = " True if a bounding volume tree should be built for the tile.\n @note The BVTree is not normally needed for layered navigation meshes."]
        pub buildBvTree: bool,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtNavMeshCreateParams"]
            [::std::mem::size_of::<dtNavMeshCreateParams>() - 208usize];
        ["Alignment of dtNavMeshCreateParams"]
            [::std::mem::align_of::<dtNavMeshCreateParams>() - 8usize];
        ["Offset of field: dtNavMeshCreateParams::verts"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, verts) - 0usize];
        ["Offset of field: dtNavMeshCreateParams::vertCount"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, vertCount) - 8usize];
        ["Offset of field: dtNavMeshCreateParams::polys"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, polys) - 16usize];
        ["Offset of field: dtNavMeshCreateParams::polyFlags"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, polyFlags) - 24usize];
        ["Offset of field: dtNavMeshCreateParams::polyAreas"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, polyAreas) - 32usize];
        ["Offset of field: dtNavMeshCreateParams::polyCount"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, polyCount) - 40usize];
        ["Offset of field: dtNavMeshCreateParams::nvp"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, nvp) - 44usize];
        ["Offset of field: dtNavMeshCreateParams::detailMeshes"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, detailMeshes) - 48usize];
        ["Offset of field: dtNavMeshCreateParams::detailVerts"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, detailVerts) - 56usize];
        ["Offset of field: dtNavMeshCreateParams::detailVertsCount"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, detailVertsCount) - 64usize];
        ["Offset of field: dtNavMeshCreateParams::detailTris"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, detailTris) - 72usize];
        ["Offset of field: dtNavMeshCreateParams::detailTriCount"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, detailTriCount) - 80usize];
        ["Offset of field: dtNavMeshCreateParams::offMeshConVerts"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, offMeshConVerts) - 88usize];
        ["Offset of field: dtNavMeshCreateParams::offMeshConRad"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, offMeshConRad) - 96usize];
        ["Offset of field: dtNavMeshCreateParams::offMeshConFlags"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, offMeshConFlags) - 104usize];
        ["Offset of field: dtNavMeshCreateParams::offMeshConAreas"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, offMeshConAreas) - 112usize];
        ["Offset of field: dtNavMeshCreateParams::offMeshConDir"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, offMeshConDir) - 120usize];
        ["Offset of field: dtNavMeshCreateParams::offMeshConUserID"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, offMeshConUserID) - 128usize];
        ["Offset of field: dtNavMeshCreateParams::offMeshConCount"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, offMeshConCount) - 136usize];
        ["Offset of field: dtNavMeshCreateParams::userId"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, userId) - 140usize];
        ["Offset of field: dtNavMeshCreateParams::tileX"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, tileX) - 144usize];
        ["Offset of field: dtNavMeshCreateParams::tileY"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, tileY) - 148usize];
        ["Offset of field: dtNavMeshCreateParams::tileLayer"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, tileLayer) - 152usize];
        ["Offset of field: dtNavMeshCreateParams::bmin"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, bmin) - 156usize];
        ["Offset of field: dtNavMeshCreateParams::bmax"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, bmax) - 168usize];
        ["Offset of field: dtNavMeshCreateParams::walkableHeight"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, walkableHeight) - 180usize];
        ["Offset of field: dtNavMeshCreateParams::walkableRadius"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, walkableRadius) - 184usize];
        ["Offset of field: dtNavMeshCreateParams::walkableClimb"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, walkableClimb) - 188usize];
        ["Offset of field: dtNavMeshCreateParams::cs"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, cs) - 192usize];
        ["Offset of field: dtNavMeshCreateParams::ch"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, ch) - 196usize];
        ["Offset of field: dtNavMeshCreateParams::buildBvTree"]
            [::std::mem::offset_of!(dtNavMeshCreateParams, buildBvTree) - 200usize];
    };
    unsafe extern "C" {
        #[doc = " Builds navigation mesh tile data from the provided tile creation data.\n @ingroup detour\n  @param[in]\t\tparams\t\tTile creation data.\n  @param[out]\toutData\t\tThe resulting tile data.\n  @param[out]\toutDataSize\tThe size of the tile data array.\n @return True if the tile data was successfully created."]
        #[link_name = "\u{1}?dtCreateNavMeshData@@YA_NPEAUdtNavMeshCreateParams@@PEAPEAEPEAH@Z"]
        pub fn dtCreateNavMeshData(
            params: *mut root::dtNavMeshCreateParams,
            outData: *mut *mut ::std::os::raw::c_uchar,
            outDataSize: *mut ::std::os::raw::c_int,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Swaps the endianness of the tile data's header (#dtMeshHeader).\n  @param[in,out]\tdata\t\tThe tile data array.\n  @param[in]\t\tdataSize\tThe size of the data array."]
        #[link_name = "\u{1}?dtNavMeshHeaderSwapEndian@@YA_NPEAEH@Z"]
        pub fn dtNavMeshHeaderSwapEndian(
            data: *mut ::std::os::raw::c_uchar,
            dataSize: ::std::os::raw::c_int,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Swaps endianness of the tile data.\n  @param[in,out]\tdata\t\tThe tile data array.\n  @param[in]\t\tdataSize\tThe size of the data array."]
        #[link_name = "\u{1}?dtNavMeshDataSwapEndian@@YA_NPEAEH@Z"]
        pub fn dtNavMeshDataSwapEndian(
            data: *mut ::std::os::raw::c_uchar,
            dataSize: ::std::os::raw::c_int,
        ) -> bool;
    }
    #[doc = " Defines polygon filtering and traversal costs for navigation mesh query operations.\n @ingroup detour"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtQueryFilter {
        #[doc = "< Cost per area type. (Used by default implementation.)"]
        pub m_areaCost: [f32; 64usize],
        #[doc = "< Flags for polygons that can be visited. (Used by default implementation.)"]
        pub m_includeFlags: ::std::os::raw::c_ushort,
        #[doc = "< Flags for polygons that should not be visited. (Used by default implementation.)"]
        pub m_excludeFlags: ::std::os::raw::c_ushort,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtQueryFilter"][::std::mem::size_of::<dtQueryFilter>() - 260usize];
        ["Alignment of dtQueryFilter"][::std::mem::align_of::<dtQueryFilter>() - 4usize];
        ["Offset of field: dtQueryFilter::m_areaCost"]
            [::std::mem::offset_of!(dtQueryFilter, m_areaCost) - 0usize];
        ["Offset of field: dtQueryFilter::m_includeFlags"]
            [::std::mem::offset_of!(dtQueryFilter, m_includeFlags) - 256usize];
        ["Offset of field: dtQueryFilter::m_excludeFlags"]
            [::std::mem::offset_of!(dtQueryFilter, m_excludeFlags) - 258usize];
    };
    unsafe extern "C" {
        #[link_name = "\u{1}?passFilter@dtQueryFilter@@QEBA_NIPEBUdtMeshTile@@PEBUdtPoly@@@Z"]
        pub fn dtQueryFilter_passFilter(
            this: *const root::dtQueryFilter,
            ref_: root::dtPolyRef,
            tile: *const root::dtMeshTile,
            poly: *const root::dtPoly,
        ) -> bool;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?getCost@dtQueryFilter@@QEBAMPEBM0IPEBUdtMeshTile@@PEBUdtPoly@@I12I12@Z"]
        pub fn dtQueryFilter_getCost(
            this: *const root::dtQueryFilter,
            pa: *const f32,
            pb: *const f32,
            prevRef: root::dtPolyRef,
            prevTile: *const root::dtMeshTile,
            prevPoly: *const root::dtPoly,
            curRef: root::dtPolyRef,
            curTile: *const root::dtMeshTile,
            curPoly: *const root::dtPoly,
            nextRef: root::dtPolyRef,
            nextTile: *const root::dtMeshTile,
            nextPoly: *const root::dtPoly,
        ) -> f32;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtQueryFilter@@QEAA@XZ"]
        pub fn dtQueryFilter_dtQueryFilter(this: *mut root::dtQueryFilter);
    }
    impl dtQueryFilter {
        #[inline]
        pub unsafe fn passFilter(
            &self,
            ref_: root::dtPolyRef,
            tile: *const root::dtMeshTile,
            poly: *const root::dtPoly,
        ) -> bool {
            dtQueryFilter_passFilter(self, ref_, tile, poly)
        }
        #[inline]
        pub unsafe fn getCost(
            &self,
            pa: *const f32,
            pb: *const f32,
            prevRef: root::dtPolyRef,
            prevTile: *const root::dtMeshTile,
            prevPoly: *const root::dtPoly,
            curRef: root::dtPolyRef,
            curTile: *const root::dtMeshTile,
            curPoly: *const root::dtPoly,
            nextRef: root::dtPolyRef,
            nextTile: *const root::dtMeshTile,
            nextPoly: *const root::dtPoly,
        ) -> f32 {
            dtQueryFilter_getCost(
                self, pa, pb, prevRef, prevTile, prevPoly, curRef, curTile, curPoly, nextRef,
                nextTile, nextPoly,
            )
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtQueryFilter_dtQueryFilter(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
    }
    #[doc = " Provides information about raycast hit\n filled by dtNavMeshQuery::raycast\n @ingroup detour"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtRaycastHit {
        #[doc = " The hit parameter. (FLT_MAX if no wall hit.)"]
        pub t: f32,
        #[doc = " hitNormal\tThe normal of the nearest wall hit. [(x, y, z)]"]
        pub hitNormal: [f32; 3usize],
        #[doc = " The index of the edge on the final polygon where the wall was hit."]
        pub hitEdgeIndex: ::std::os::raw::c_int,
        #[doc = " Pointer to an array of reference ids of the visited polygons. [opt]"]
        pub path: *mut root::dtPolyRef,
        #[doc = " The number of visited polygons. [opt]"]
        pub pathCount: ::std::os::raw::c_int,
        #[doc = " The maximum number of polygons the @p path array can hold."]
        pub maxPath: ::std::os::raw::c_int,
        #[doc = "  The cost of the path until hit."]
        pub pathCost: f32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtRaycastHit"][::std::mem::size_of::<dtRaycastHit>() - 48usize];
        ["Alignment of dtRaycastHit"][::std::mem::align_of::<dtRaycastHit>() - 8usize];
        ["Offset of field: dtRaycastHit::t"][::std::mem::offset_of!(dtRaycastHit, t) - 0usize];
        ["Offset of field: dtRaycastHit::hitNormal"]
            [::std::mem::offset_of!(dtRaycastHit, hitNormal) - 4usize];
        ["Offset of field: dtRaycastHit::hitEdgeIndex"]
            [::std::mem::offset_of!(dtRaycastHit, hitEdgeIndex) - 16usize];
        ["Offset of field: dtRaycastHit::path"]
            [::std::mem::offset_of!(dtRaycastHit, path) - 24usize];
        ["Offset of field: dtRaycastHit::pathCount"]
            [::std::mem::offset_of!(dtRaycastHit, pathCount) - 32usize];
        ["Offset of field: dtRaycastHit::maxPath"]
            [::std::mem::offset_of!(dtRaycastHit, maxPath) - 36usize];
        ["Offset of field: dtRaycastHit::pathCost"]
            [::std::mem::offset_of!(dtRaycastHit, pathCost) - 40usize];
    };
    #[repr(C)]
    pub struct dtPolyQuery__bindgen_vtable(::std::os::raw::c_void);
    #[doc = " Provides custom polygon query behavior.\n Used by dtNavMeshQuery::queryPolygons.\n @ingroup detour"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtPolyQuery {
        pub vtable_: *const dtPolyQuery__bindgen_vtable,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtPolyQuery"][::std::mem::size_of::<dtPolyQuery>() - 8usize];
        ["Alignment of dtPolyQuery"][::std::mem::align_of::<dtPolyQuery>() - 8usize];
    };
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtPolyQuery@@UEAA@XZ"]
        pub fn dtPolyQuery_dtPolyQuery_destructor(this: *mut root::dtPolyQuery);
    }
    #[doc = " Provides the ability to perform pathfinding related queries against\n a navigation mesh.\n @ingroup detour"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtNavMeshQuery {
        #[doc = "< Pointer to navmesh data."]
        pub m_nav: *const root::dtNavMesh,
        #[doc = "< Sliced query state."]
        pub m_query: root::dtNavMeshQuery_dtQueryData,
        #[doc = "< Pointer to small node pool."]
        pub m_tinyNodePool: *mut root::dtNodePool,
        #[doc = "< Pointer to node pool."]
        pub m_nodePool: *mut root::dtNodePool,
        #[doc = "< Pointer to open list queue."]
        pub m_openList: *mut root::dtNodeQueue,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtNavMeshQuery_dtQueryData {
        pub status: root::dtStatus,
        pub lastBestNode: *mut root::dtNode,
        pub lastBestNodeCost: f32,
        pub startRef: root::dtPolyRef,
        pub endRef: root::dtPolyRef,
        pub startPos: [f32; 3usize],
        pub endPos: [f32; 3usize],
        pub filter: *const root::dtQueryFilter,
        pub options: ::std::os::raw::c_uint,
        pub raycastLimitSqr: f32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtNavMeshQuery_dtQueryData"]
            [::std::mem::size_of::<dtNavMeshQuery_dtQueryData>() - 72usize];
        ["Alignment of dtNavMeshQuery_dtQueryData"]
            [::std::mem::align_of::<dtNavMeshQuery_dtQueryData>() - 8usize];
        ["Offset of field: dtNavMeshQuery_dtQueryData::status"]
            [::std::mem::offset_of!(dtNavMeshQuery_dtQueryData, status) - 0usize];
        ["Offset of field: dtNavMeshQuery_dtQueryData::lastBestNode"]
            [::std::mem::offset_of!(dtNavMeshQuery_dtQueryData, lastBestNode) - 8usize];
        ["Offset of field: dtNavMeshQuery_dtQueryData::lastBestNodeCost"]
            [::std::mem::offset_of!(dtNavMeshQuery_dtQueryData, lastBestNodeCost) - 16usize];
        ["Offset of field: dtNavMeshQuery_dtQueryData::startRef"]
            [::std::mem::offset_of!(dtNavMeshQuery_dtQueryData, startRef) - 20usize];
        ["Offset of field: dtNavMeshQuery_dtQueryData::endRef"]
            [::std::mem::offset_of!(dtNavMeshQuery_dtQueryData, endRef) - 24usize];
        ["Offset of field: dtNavMeshQuery_dtQueryData::startPos"]
            [::std::mem::offset_of!(dtNavMeshQuery_dtQueryData, startPos) - 28usize];
        ["Offset of field: dtNavMeshQuery_dtQueryData::endPos"]
            [::std::mem::offset_of!(dtNavMeshQuery_dtQueryData, endPos) - 40usize];
        ["Offset of field: dtNavMeshQuery_dtQueryData::filter"]
            [::std::mem::offset_of!(dtNavMeshQuery_dtQueryData, filter) - 56usize];
        ["Offset of field: dtNavMeshQuery_dtQueryData::options"]
            [::std::mem::offset_of!(dtNavMeshQuery_dtQueryData, options) - 64usize];
        ["Offset of field: dtNavMeshQuery_dtQueryData::raycastLimitSqr"]
            [::std::mem::offset_of!(dtNavMeshQuery_dtQueryData, raycastLimitSqr) - 68usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtNavMeshQuery"][::std::mem::size_of::<dtNavMeshQuery>() - 104usize];
        ["Alignment of dtNavMeshQuery"][::std::mem::align_of::<dtNavMeshQuery>() - 8usize];
        ["Offset of field: dtNavMeshQuery::m_nav"]
            [::std::mem::offset_of!(dtNavMeshQuery, m_nav) - 0usize];
        ["Offset of field: dtNavMeshQuery::m_query"]
            [::std::mem::offset_of!(dtNavMeshQuery, m_query) - 8usize];
        ["Offset of field: dtNavMeshQuery::m_tinyNodePool"]
            [::std::mem::offset_of!(dtNavMeshQuery, m_tinyNodePool) - 80usize];
        ["Offset of field: dtNavMeshQuery::m_nodePool"]
            [::std::mem::offset_of!(dtNavMeshQuery, m_nodePool) - 88usize];
        ["Offset of field: dtNavMeshQuery::m_openList"]
            [::std::mem::offset_of!(dtNavMeshQuery, m_openList) - 96usize];
    };
    unsafe extern "C" {
        #[doc = " Initializes the query object.\n  @param[in]\t\tnav\t\t\tPointer to the dtNavMesh object to use for all queries.\n  @param[in]\t\tmaxNodes\tMaximum number of search nodes. [Limits: 0 < value <= 65535]\n @returns The status flags for the query."]
        #[link_name = "\u{1}?init@dtNavMeshQuery@@QEAAIPEBVdtNavMesh@@H@Z"]
        pub fn dtNavMeshQuery_init(
            this: *mut root::dtNavMeshQuery,
            nav: *const root::dtNavMesh,
            maxNodes: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds a path from the start polygon to the end polygon.\n  @param[in]\t\tstartRef\tThe reference id of the start polygon.\n  @param[in]\t\tendRef\t\tThe reference id of the end polygon.\n  @param[in]\t\tstartPos\tA position within the start polygon. [(x, y, z)]\n  @param[in]\t\tendPos\t\tA position within the end polygon. [(x, y, z)]\n  @param[in]\t\tfilter\t\tThe polygon filter to apply to the query.\n  @param[out]\tpath\t\tAn ordered list of polygon references representing the path. (Start to end.)\n  \t\t\t\t\t\t\t[(polyRef) * @p pathCount]\n  @param[out]\tpathCount\tThe number of polygons returned in the @p path array.\n  @param[in]\t\tmaxPath\t\tThe maximum number of polygons the @p path array can hold. [Limit: >= 1]"]
        #[link_name = "\u{1}?findPath@dtNavMeshQuery@@QEBAIIIPEBM0PEBVdtQueryFilter@@PEAIPEAHH@Z"]
        pub fn dtNavMeshQuery_findPath(
            this: *const root::dtNavMeshQuery,
            startRef: root::dtPolyRef,
            endRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
            path: *mut root::dtPolyRef,
            pathCount: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds the straight path from the start to the end position within the polygon corridor.\n  @param[in]\t\tstartPos\t\t\tPath start position. [(x, y, z)]\n  @param[in]\t\tendPos\t\t\t\tPath end position. [(x, y, z)]\n  @param[in]\t\tpath\t\t\t\tAn array of polygon references that represent the path corridor.\n  @param[in]\t\tpathSize\t\t\tThe number of polygons in the @p path array.\n  @param[out]\tstraightPath\t\tPoints describing the straight path. [(x, y, z) * @p straightPathCount].\n  @param[out]\tstraightPathFlags\tFlags describing each point. (See: #dtStraightPathFlags) [opt]\n  @param[out]\tstraightPathRefs\tThe reference id of the polygon that is being entered at each point. [opt]\n  @param[out]\tstraightPathCount\tThe number of points in the straight path.\n  @param[in]\t\tmaxStraightPath\t\tThe maximum number of points the straight path arrays can hold.  [Limit: > 0]\n  @param[in]\t\toptions\t\t\t\tQuery options. (see: #dtStraightPathOptions)\n @returns The status flags for the query."]
        #[link_name = "\u{1}?findStraightPath@dtNavMeshQuery@@QEBAIPEBM0PEBIHPEAMPEAEPEAIPEAHHH@Z"]
        pub fn dtNavMeshQuery_findStraightPath(
            this: *const root::dtNavMeshQuery,
            startPos: *const f32,
            endPos: *const f32,
            path: *const root::dtPolyRef,
            pathSize: ::std::os::raw::c_int,
            straightPath: *mut f32,
            straightPathFlags: *mut ::std::os::raw::c_uchar,
            straightPathRefs: *mut root::dtPolyRef,
            straightPathCount: *mut ::std::os::raw::c_int,
            maxStraightPath: ::std::os::raw::c_int,
            options: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Initializes a sliced path query.\n  @param[in]\t\tstartRef\tThe reference id of the start polygon.\n  @param[in]\t\tendRef\t\tThe reference id of the end polygon.\n  @param[in]\t\tstartPos\tA position within the start polygon. [(x, y, z)]\n  @param[in]\t\tendPos\t\tA position within the end polygon. [(x, y, z)]\n  @param[in]\t\tfilter\t\tThe polygon filter to apply to the query.\n  @param[in]\t\toptions\t\tquery options (see: #dtFindPathOptions)\n @returns The status flags for the query."]
        #[link_name = "\u{1}?initSlicedFindPath@dtNavMeshQuery@@QEAAIIIPEBM0PEBVdtQueryFilter@@I@Z"]
        pub fn dtNavMeshQuery_initSlicedFindPath(
            this: *mut root::dtNavMeshQuery,
            startRef: root::dtPolyRef,
            endRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
            options: ::std::os::raw::c_uint,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Updates an in-progress sliced path query.\n  @param[in]\t\tmaxIter\t\tThe maximum number of iterations to perform.\n  @param[out]\tdoneIters\tThe actual number of iterations completed. [opt]\n @returns The status flags for the query."]
        #[link_name = "\u{1}?updateSlicedFindPath@dtNavMeshQuery@@QEAAIHPEAH@Z"]
        pub fn dtNavMeshQuery_updateSlicedFindPath(
            this: *mut root::dtNavMeshQuery,
            maxIter: ::std::os::raw::c_int,
            doneIters: *mut ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finalizes and returns the results of a sliced path query.\n  @param[out]\tpath\t\tAn ordered list of polygon references representing the path. (Start to end.)\n  \t\t\t\t\t\t\t[(polyRef) * @p pathCount]\n  @param[out]\tpathCount\tThe number of polygons returned in the @p path array.\n  @param[in]\t\tmaxPath\t\tThe max number of polygons the path array can hold. [Limit: >= 1]\n @returns The status flags for the query."]
        #[link_name = "\u{1}?finalizeSlicedFindPath@dtNavMeshQuery@@QEAAIPEAIPEAHH@Z"]
        pub fn dtNavMeshQuery_finalizeSlicedFindPath(
            this: *mut root::dtNavMeshQuery,
            path: *mut root::dtPolyRef,
            pathCount: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest\n polygon on the existing path that was visited during the search.\n  @param[in]\t\texisting\t\tAn array of polygon references for the existing path.\n  @param[in]\t\texistingSize\tThe number of polygon in the @p existing array.\n  @param[out]\tpath\t\t\tAn ordered list of polygon references representing the path. (Start to end.)\n  \t\t\t\t\t\t\t\t[(polyRef) * @p pathCount]\n  @param[out]\tpathCount\t\tThe number of polygons returned in the @p path array.\n  @param[in]\t\tmaxPath\t\t\tThe max number of polygons the @p path array can hold. [Limit: >= 1]\n @returns The status flags for the query."]
        #[link_name = "\u{1}?finalizeSlicedFindPathPartial@dtNavMeshQuery@@QEAAIPEBIHPEAIPEAHH@Z"]
        pub fn dtNavMeshQuery_finalizeSlicedFindPathPartial(
            this: *mut root::dtNavMeshQuery,
            existing: *const root::dtPolyRef,
            existingSize: ::std::os::raw::c_int,
            path: *mut root::dtPolyRef,
            pathCount: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds the polygons along the navigation graph that touch the specified circle.\n  @param[in]\t\tstartRef\t\tThe reference id of the polygon where the search starts.\n  @param[in]\t\tcenterPos\t\tThe center of the search circle. [(x, y, z)]\n  @param[in]\t\tradius\t\t\tThe radius of the search circle.\n  @param[in]\t\tfilter\t\t\tThe polygon filter to apply to the query.\n  @param[out]\tresultRef\t\tThe reference ids of the polygons touched by the circle. [opt]\n  @param[out]\tresultParent\tThe reference ids of the parent polygons for each result.\n  \t\t\t\t\t\t\t\tZero if a result polygon has no parent. [opt]\n  @param[out]\tresultCost\t\tThe search cost from @p centerPos to the polygon. [opt]\n  @param[out]\tresultCount\t\tThe number of polygons found. [opt]\n  @param[in]\t\tmaxResult\t\tThe maximum number of polygons the result arrays can hold.\n @returns The status flags for the query."]
        #[link_name = "\u{1}?findPolysAroundCircle@dtNavMeshQuery@@QEBAIIPEBMMPEBVdtQueryFilter@@PEAI2PEAMPEAHH@Z"]
        pub fn dtNavMeshQuery_findPolysAroundCircle(
            this: *const root::dtNavMeshQuery,
            startRef: root::dtPolyRef,
            centerPos: *const f32,
            radius: f32,
            filter: *const root::dtQueryFilter,
            resultRef: *mut root::dtPolyRef,
            resultParent: *mut root::dtPolyRef,
            resultCost: *mut f32,
            resultCount: *mut ::std::os::raw::c_int,
            maxResult: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds the polygons along the naviation graph that touch the specified convex polygon.\n  @param[in]\t\tstartRef\t\tThe reference id of the polygon where the search starts.\n  @param[in]\t\tverts\t\t\tThe vertices describing the convex polygon. (CCW)\n  \t\t\t\t\t\t\t\t[(x, y, z) * @p nverts]\n  @param[in]\t\tnverts\t\t\tThe number of vertices in the polygon.\n  @param[in]\t\tfilter\t\t\tThe polygon filter to apply to the query.\n  @param[out]\tresultRef\t\tThe reference ids of the polygons touched by the search polygon. [opt]\n  @param[out]\tresultParent\tThe reference ids of the parent polygons for each result. Zero if a\n  \t\t\t\t\t\t\t\tresult polygon has no parent. [opt]\n  @param[out]\tresultCost\t\tThe search cost from the centroid point to the polygon. [opt]\n  @param[out]\tresultCount\t\tThe number of polygons found.\n  @param[in]\t\tmaxResult\t\tThe maximum number of polygons the result arrays can hold.\n @returns The status flags for the query."]
        #[link_name = "\u{1}?findPolysAroundShape@dtNavMeshQuery@@QEBAIIPEBMHPEBVdtQueryFilter@@PEAI2PEAMPEAHH@Z"]
        pub fn dtNavMeshQuery_findPolysAroundShape(
            this: *const root::dtNavMeshQuery,
            startRef: root::dtPolyRef,
            verts: *const f32,
            nverts: ::std::os::raw::c_int,
            filter: *const root::dtQueryFilter,
            resultRef: *mut root::dtPolyRef,
            resultParent: *mut root::dtPolyRef,
            resultCost: *mut f32,
            resultCount: *mut ::std::os::raw::c_int,
            maxResult: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Gets a path from the explored nodes in the previous search.\n  @param[in]\t\tendRef\t\tThe reference id of the end polygon.\n  @param[out]\tpath\t\tAn ordered list of polygon references representing the path. (Start to end.)\n  \t\t\t\t\t\t\t[(polyRef) * @p pathCount]\n  @param[out]\tpathCount\tThe number of polygons returned in the @p path array.\n  @param[in]\t\tmaxPath\t\tThe maximum number of polygons the @p path array can hold. [Limit: >= 0]\n  @returns\t\tThe status flags. Returns DT_FAILURE | DT_INVALID_PARAM if any parameter is wrong, or if\n  \t\t\t\t@p endRef was not explored in the previous search. Returns DT_SUCCESS | DT_BUFFER_TOO_SMALL\n  \t\t\t\tif @p path cannot contain the entire path. In this case it is filled to capacity with a partial path.\n  \t\t\t\tOtherwise returns DT_SUCCESS.\n  @remarks\t\tThe result of this function depends on the state of the query object. For that reason it should only\n  \t\t\t\tbe used immediately after one of the two Dijkstra searches, findPolysAroundCircle or findPolysAroundShape."]
        #[link_name = "\u{1}?getPathFromDijkstraSearch@dtNavMeshQuery@@QEBAIIPEAIPEAHH@Z"]
        pub fn dtNavMeshQuery_getPathFromDijkstraSearch(
            this: *const root::dtNavMeshQuery,
            endRef: root::dtPolyRef,
            path: *mut root::dtPolyRef,
            pathCount: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds the polygon nearest to the specified center point.\n [opt] means the specified parameter can be a null pointer, in that case the output parameter will not be set.\n\n  @param[in]\t\tcenter\t\tThe center of the search box. [(x, y, z)]\n  @param[in]\t\thalfExtents\tThe search distance along each axis. [(x, y, z)]\n  @param[in]\t\tfilter\t\tThe polygon filter to apply to the query.\n  @param[out]\tnearestRef\tThe reference id of the nearest polygon. Will be set to 0 if no polygon is found.\n  @param[out]\tnearestPt\tThe nearest point on the polygon. Unchanged if no polygon is found. [opt] [(x, y, z)]\n @returns The status flags for the query."]
        #[link_name = "\u{1}?findNearestPoly@dtNavMeshQuery@@QEBAIPEBM0PEBVdtQueryFilter@@PEAIPEAM@Z"]
        pub fn dtNavMeshQuery_findNearestPoly(
            this: *const root::dtNavMeshQuery,
            center: *const f32,
            halfExtents: *const f32,
            filter: *const root::dtQueryFilter,
            nearestRef: *mut root::dtPolyRef,
            nearestPt: *mut f32,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds the polygon nearest to the specified center point.\n [opt] means the specified parameter can be a null pointer, in that case the output parameter will not be set.\n\n  @param[in]\t\tcenter\t\tThe center of the search box. [(x, y, z)]\n  @param[in]\t\thalfExtents\tThe search distance along each axis. [(x, y, z)]\n  @param[in]\t\tfilter\t\tThe polygon filter to apply to the query.\n  @param[out]\tnearestRef\tThe reference id of the nearest polygon. Will be set to 0 if no polygon is found.\n  @param[out]\tnearestPt\tThe nearest point on the polygon. Unchanged if no polygon is found. [opt] [(x, y, z)]\n  @param[out]\tisOverPoly \tSet to true if the point's X/Z coordinate lies inside the polygon, false otherwise. Unchanged if no polygon is found. [opt]\n @returns The status flags for the query."]
        #[link_name = "\u{1}?findNearestPoly@dtNavMeshQuery@@QEBAIPEBM0PEBVdtQueryFilter@@PEAIPEAMPEA_N@Z"]
        pub fn dtNavMeshQuery_findNearestPoly1(
            this: *const root::dtNavMeshQuery,
            center: *const f32,
            halfExtents: *const f32,
            filter: *const root::dtQueryFilter,
            nearestRef: *mut root::dtPolyRef,
            nearestPt: *mut f32,
            isOverPoly: *mut bool,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds polygons that overlap the search box.\n  @param[in]\t\tcenter\t\tThe center of the search box. [(x, y, z)]\n  @param[in]\t\thalfExtents\t\tThe search distance along each axis. [(x, y, z)]\n  @param[in]\t\tfilter\t\tThe polygon filter to apply to the query.\n  @param[out]\tpolys\t\tThe reference ids of the polygons that overlap the query box.\n  @param[out]\tpolyCount\tThe number of polygons in the search result.\n  @param[in]\t\tmaxPolys\tThe maximum number of polygons the search result can hold.\n @returns The status flags for the query."]
        #[link_name = "\u{1}?queryPolygons@dtNavMeshQuery@@QEBAIPEBM0PEBVdtQueryFilter@@PEAIPEAHH@Z"]
        pub fn dtNavMeshQuery_queryPolygons(
            this: *const root::dtNavMeshQuery,
            center: *const f32,
            halfExtents: *const f32,
            filter: *const root::dtQueryFilter,
            polys: *mut root::dtPolyRef,
            polyCount: *mut ::std::os::raw::c_int,
            maxPolys: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds polygons that overlap the search box.\n  @param[in]\t\tcenter\t\tThe center of the search box. [(x, y, z)]\n  @param[in]\t\thalfExtents\t\tThe search distance along each axis. [(x, y, z)]\n  @param[in]\t\tfilter\t\tThe polygon filter to apply to the query.\n  @param[in]\t\tquery\t\tThe query. Polygons found will be batched together and passed to this query."]
        #[link_name = "\u{1}?queryPolygons@dtNavMeshQuery@@QEBAIPEBM0PEBVdtQueryFilter@@PEAVdtPolyQuery@@@Z"]
        pub fn dtNavMeshQuery_queryPolygons1(
            this: *const root::dtNavMeshQuery,
            center: *const f32,
            halfExtents: *const f32,
            filter: *const root::dtQueryFilter,
            query: *mut root::dtPolyQuery,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds the non-overlapping navigation polygons in the local neighbourhood around the center position.\n  @param[in]\t\tstartRef\t\tThe reference id of the polygon where the search starts.\n  @param[in]\t\tcenterPos\t\tThe center of the query circle. [(x, y, z)]\n  @param[in]\t\tradius\t\t\tThe radius of the query circle.\n  @param[in]\t\tfilter\t\t\tThe polygon filter to apply to the query.\n  @param[out]\tresultRef\t\tThe reference ids of the polygons touched by the circle.\n  @param[out]\tresultParent\tThe reference ids of the parent polygons for each result.\n  \t\t\t\t\t\t\t\tZero if a result polygon has no parent. [opt]\n  @param[out]\tresultCount\t\tThe number of polygons found.\n  @param[in]\t\tmaxResult\t\tThe maximum number of polygons the result arrays can hold.\n @returns The status flags for the query."]
        #[link_name = "\u{1}?findLocalNeighbourhood@dtNavMeshQuery@@QEBAIIPEBMMPEBVdtQueryFilter@@PEAI2PEAHH@Z"]
        pub fn dtNavMeshQuery_findLocalNeighbourhood(
            this: *const root::dtNavMeshQuery,
            startRef: root::dtPolyRef,
            centerPos: *const f32,
            radius: f32,
            filter: *const root::dtQueryFilter,
            resultRef: *mut root::dtPolyRef,
            resultParent: *mut root::dtPolyRef,
            resultCount: *mut ::std::os::raw::c_int,
            maxResult: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Moves from the start to the end position constrained to the navigation mesh.\n  @param[in]\t\tstartRef\t\tThe reference id of the start polygon.\n  @param[in]\t\tstartPos\t\tA position of the mover within the start polygon. [(x, y, x)]\n  @param[in]\t\tendPos\t\t\tThe desired end position of the mover. [(x, y, z)]\n  @param[in]\t\tfilter\t\t\tThe polygon filter to apply to the query.\n  @param[out]\tresultPos\t\tThe result position of the mover. [(x, y, z)]\n  @param[out]\tvisited\t\t\tThe reference ids of the polygons visited during the move.\n  @param[out]\tvisitedCount\tThe number of polygons visited during the move.\n  @param[in]\t\tmaxVisitedSize\tThe maximum number of polygons the @p visited array can hold.\n @returns The status flags for the query."]
        #[link_name = "\u{1}?moveAlongSurface@dtNavMeshQuery@@QEBAIIPEBM0PEBVdtQueryFilter@@PEAMPEAIPEAHH@Z"]
        pub fn dtNavMeshQuery_moveAlongSurface(
            this: *const root::dtNavMeshQuery,
            startRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
            resultPos: *mut f32,
            visited: *mut root::dtPolyRef,
            visitedCount: *mut ::std::os::raw::c_int,
            maxVisitedSize: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Casts a 'walkability' ray along the surface of the navigation mesh from\n the start position toward the end position.\n @note A wrapper around raycast(..., RaycastHit*). Retained for backward compatibility.\n  @param[in]\t\tstartRef\tThe reference id of the start polygon.\n  @param[in]\t\tstartPos\tA position within the start polygon representing\n  \t\t\t\t\t\t\tthe start of the ray. [(x, y, z)]\n  @param[in]\t\tendPos\t\tThe position to cast the ray toward. [(x, y, z)]\n  @param[in]\t\tfilter\t\tThe polygon filter to apply to the query.\n  @param[out]\tt\t\t\tThe hit parameter. (FLT_MAX if no wall hit.)\n  @param[out]\thitNormal\tThe normal of the nearest wall hit. [(x, y, z)]\n  @param[out]\tpath\t\tThe reference ids of the visited polygons. [opt]\n  @param[out]\tpathCount\tThe number of visited polygons. [opt]\n  @param[in]\t\tmaxPath\t\tThe maximum number of polygons the @p path array can hold.\n @returns The status flags for the query."]
        #[link_name = "\u{1}?raycast@dtNavMeshQuery@@QEBAIIPEBM0PEBVdtQueryFilter@@PEAM2PEAIPEAHH@Z"]
        pub fn dtNavMeshQuery_raycast(
            this: *const root::dtNavMeshQuery,
            startRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
            t: *mut f32,
            hitNormal: *mut f32,
            path: *mut root::dtPolyRef,
            pathCount: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Casts a 'walkability' ray along the surface of the navigation mesh from\n the start position toward the end position.\n  @param[in]\t\tstartRef\tThe reference id of the start polygon.\n  @param[in]\t\tstartPos\tA position within the start polygon representing\n  \t\t\t\t\t\t\tthe start of the ray. [(x, y, z)]\n  @param[in]\t\tendPos\t\tThe position to cast the ray toward. [(x, y, z)]\n  @param[in]\t\tfilter\t\tThe polygon filter to apply to the query.\n  @param[in]\t\toptions\t\tgovern how the raycast behaves. See dtRaycastOptions\n  @param[out]\thit\t\t\tPointer to a raycast hit structure which will be filled by the results.\n  @param[in]\t\tprevRef\t\tparent of start ref. Used during for cost calculation [opt]\n @returns The status flags for the query."]
        #[link_name = "\u{1}?raycast@dtNavMeshQuery@@QEBAIIPEBM0PEBVdtQueryFilter@@IPEAUdtRaycastHit@@I@Z"]
        pub fn dtNavMeshQuery_raycast1(
            this: *const root::dtNavMeshQuery,
            startRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
            options: ::std::os::raw::c_uint,
            hit: *mut root::dtRaycastHit,
            prevRef: root::dtPolyRef,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds the distance from the specified position to the nearest polygon wall.\n  @param[in]\t\tstartRef\t\tThe reference id of the polygon containing @p centerPos.\n  @param[in]\t\tcenterPos\t\tThe center of the search circle. [(x, y, z)]\n  @param[in]\t\tmaxRadius\t\tThe radius of the search circle.\n  @param[in]\t\tfilter\t\t\tThe polygon filter to apply to the query.\n  @param[out]\thitDist\t\t\tThe distance to the nearest wall from @p centerPos.\n  @param[out]\thitPos\t\t\tThe nearest position on the wall that was hit. [(x, y, z)]\n  @param[out]\thitNormal\t\tThe normalized ray formed from the wall point to the\n  \t\t\t\t\t\t\t\tsource point. [(x, y, z)]\n @returns The status flags for the query."]
        #[link_name = "\u{1}?findDistanceToWall@dtNavMeshQuery@@QEBAIIPEBMMPEBVdtQueryFilter@@PEAM22@Z"]
        pub fn dtNavMeshQuery_findDistanceToWall(
            this: *const root::dtNavMeshQuery,
            startRef: root::dtPolyRef,
            centerPos: *const f32,
            maxRadius: f32,
            filter: *const root::dtQueryFilter,
            hitDist: *mut f32,
            hitPos: *mut f32,
            hitNormal: *mut f32,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Returns the segments for the specified polygon, optionally including portals.\n  @param[in]\t\tref\t\t\t\tThe reference id of the polygon.\n  @param[in]\t\tfilter\t\t\tThe polygon filter to apply to the query.\n  @param[out]\tsegmentVerts\tThe segments. [(ax, ay, az, bx, by, bz) * segmentCount]\n  @param[out]\tsegmentRefs\t\tThe reference ids of each segment's neighbor polygon.\n  \t\t\t\t\t\t\t\tOr zero if the segment is a wall. [opt] [(parentRef) * @p segmentCount]\n  @param[out]\tsegmentCount\tThe number of segments returned.\n  @param[in]\t\tmaxSegments\t\tThe maximum number of segments the result arrays can hold.\n @returns The status flags for the query."]
        #[link_name = "\u{1}?getPolyWallSegments@dtNavMeshQuery@@QEBAIIPEBVdtQueryFilter@@PEAMPEAIPEAHH@Z"]
        pub fn dtNavMeshQuery_getPolyWallSegments(
            this: *const root::dtNavMeshQuery,
            ref_: root::dtPolyRef,
            filter: *const root::dtQueryFilter,
            segmentVerts: *mut f32,
            segmentRefs: *mut root::dtPolyRef,
            segmentCount: *mut ::std::os::raw::c_int,
            maxSegments: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Returns random location on navmesh.\n Polygons are chosen weighted by area. The search runs in linear related to number of polygon.\n  @param[in]\t\tfilter\t\t\tThe polygon filter to apply to the query.\n  @param[in]\t\tfrand\t\t\tFunction returning a random number [0..1).\n  @param[out]\trandomRef\t\tThe reference id of the random location.\n  @param[out]\trandomPt\t\tThe random location.\n @returns The status flags for the query."]
        #[link_name = "\u{1}?findRandomPoint@dtNavMeshQuery@@QEBAIPEBVdtQueryFilter@@P6AMXZPEAIPEAM@Z"]
        pub fn dtNavMeshQuery_findRandomPoint(
            this: *const root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
            frand: ::std::option::Option<unsafe extern "C" fn() -> f32>,
            randomRef: *mut root::dtPolyRef,
            randomPt: *mut f32,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Returns random location on navmesh within the reach of specified location.\n Polygons are chosen weighted by area. The search runs in linear related to number of polygon.\n The location is not exactly constrained by the circle, but it limits the visited polygons.\n  @param[in]\t\tstartRef\t\tThe reference id of the polygon where the search starts.\n  @param[in]\t\tcenterPos\t\tThe center of the search circle. [(x, y, z)]\n  @param[in]\t\tmaxRadius\t\tThe radius of the search circle. [Units: wu]\n  @param[in]\t\tfilter\t\t\tThe polygon filter to apply to the query.\n  @param[in]\t\tfrand\t\t\tFunction returning a random number [0..1).\n  @param[out]\trandomRef\t\tThe reference id of the random location.\n  @param[out]\trandomPt\t\tThe random location. [(x, y, z)]\n @returns The status flags for the query."]
        #[link_name = "\u{1}?findRandomPointAroundCircle@dtNavMeshQuery@@QEBAIIPEBMMPEBVdtQueryFilter@@P6AMXZPEAIPEAM@Z"]
        pub fn dtNavMeshQuery_findRandomPointAroundCircle(
            this: *const root::dtNavMeshQuery,
            startRef: root::dtPolyRef,
            centerPos: *const f32,
            maxRadius: f32,
            filter: *const root::dtQueryFilter,
            frand: ::std::option::Option<unsafe extern "C" fn() -> f32>,
            randomRef: *mut root::dtPolyRef,
            randomPt: *mut f32,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Finds the closest point on the specified polygon.\n  @param[in]\t\tref\t\t\tThe reference id of the polygon.\n  @param[in]\t\tpos\t\t\tThe position to check. [(x, y, z)]\n  @param[out]\tclosest\t\tThe closest point on the polygon. [(x, y, z)]\n  @param[out]\tposOverPoly\tTrue of the position is over the polygon.\n @returns The status flags for the query."]
        #[link_name = "\u{1}?closestPointOnPoly@dtNavMeshQuery@@QEBAIIPEBMPEAMPEA_N@Z"]
        pub fn dtNavMeshQuery_closestPointOnPoly(
            this: *const root::dtNavMeshQuery,
            ref_: root::dtPolyRef,
            pos: *const f32,
            closest: *mut f32,
            posOverPoly: *mut bool,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Returns a point on the boundary closest to the source point if the source point is outside the\n polygon's xz-bounds.\n  @param[in]\t\tref\t\t\tThe reference id to the polygon.\n  @param[in]\t\tpos\t\t\tThe position to check. [(x, y, z)]\n  @param[out]\tclosest\t\tThe closest point. [(x, y, z)]\n @returns The status flags for the query."]
        #[link_name = "\u{1}?closestPointOnPolyBoundary@dtNavMeshQuery@@QEBAIIPEBMPEAM@Z"]
        pub fn dtNavMeshQuery_closestPointOnPolyBoundary(
            this: *const root::dtNavMeshQuery,
            ref_: root::dtPolyRef,
            pos: *const f32,
            closest: *mut f32,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Gets the height of the polygon at the provided position using the height detail. (Most accurate.)\n  @param[in]\t\tref\t\t\tThe reference id of the polygon.\n  @param[in]\t\tpos\t\t\tA position within the xz-bounds of the polygon. [(x, y, z)]\n  @param[out]\theight\t\tThe height at the surface of the polygon.\n @returns The status flags for the query."]
        #[link_name = "\u{1}?getPolyHeight@dtNavMeshQuery@@QEBAIIPEBMPEAM@Z"]
        pub fn dtNavMeshQuery_getPolyHeight(
            this: *const root::dtNavMeshQuery,
            ref_: root::dtPolyRef,
            pos: *const f32,
            height: *mut f32,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Returns true if the polygon reference is valid and passes the filter restrictions.\n  @param[in]\t\tref\t\t\tThe polygon reference to check.\n  @param[in]\t\tfilter\t\tThe filter to apply."]
        #[link_name = "\u{1}?isValidPolyRef@dtNavMeshQuery@@QEBA_NIPEBVdtQueryFilter@@@Z"]
        pub fn dtNavMeshQuery_isValidPolyRef(
            this: *const root::dtNavMeshQuery,
            ref_: root::dtPolyRef,
            filter: *const root::dtQueryFilter,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Returns true if the polygon reference is in the closed list.\n  @param[in]\t\tref\t\tThe reference id of the polygon to check.\n @returns True if the polygon is in closed list."]
        #[link_name = "\u{1}?isInClosedList@dtNavMeshQuery@@QEBA_NI@Z"]
        pub fn dtNavMeshQuery_isInClosedList(
            this: *const root::dtNavMeshQuery,
            ref_: root::dtPolyRef,
        ) -> bool;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtNavMeshQuery@@QEAA@XZ"]
        pub fn dtNavMeshQuery_dtNavMeshQuery(this: *mut root::dtNavMeshQuery);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtNavMeshQuery@@QEAA@XZ"]
        pub fn dtNavMeshQuery_dtNavMeshQuery_destructor(this: *mut root::dtNavMeshQuery);
    }
    impl dtNavMeshQuery {
        #[inline]
        pub unsafe fn init(
            &mut self,
            nav: *const root::dtNavMesh,
            maxNodes: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_init(self, nav, maxNodes)
        }
        #[inline]
        pub unsafe fn findPath(
            &self,
            startRef: root::dtPolyRef,
            endRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
            path: *mut root::dtPolyRef,
            pathCount: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_findPath(
                self, startRef, endRef, startPos, endPos, filter, path, pathCount, maxPath,
            )
        }
        #[inline]
        pub unsafe fn findStraightPath(
            &self,
            startPos: *const f32,
            endPos: *const f32,
            path: *const root::dtPolyRef,
            pathSize: ::std::os::raw::c_int,
            straightPath: *mut f32,
            straightPathFlags: *mut ::std::os::raw::c_uchar,
            straightPathRefs: *mut root::dtPolyRef,
            straightPathCount: *mut ::std::os::raw::c_int,
            maxStraightPath: ::std::os::raw::c_int,
            options: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_findStraightPath(
                self,
                startPos,
                endPos,
                path,
                pathSize,
                straightPath,
                straightPathFlags,
                straightPathRefs,
                straightPathCount,
                maxStraightPath,
                options,
            )
        }
        #[inline]
        pub unsafe fn initSlicedFindPath(
            &mut self,
            startRef: root::dtPolyRef,
            endRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
            options: ::std::os::raw::c_uint,
        ) -> root::dtStatus {
            dtNavMeshQuery_initSlicedFindPath(
                self, startRef, endRef, startPos, endPos, filter, options,
            )
        }
        #[inline]
        pub unsafe fn updateSlicedFindPath(
            &mut self,
            maxIter: ::std::os::raw::c_int,
            doneIters: *mut ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_updateSlicedFindPath(self, maxIter, doneIters)
        }
        #[inline]
        pub unsafe fn finalizeSlicedFindPath(
            &mut self,
            path: *mut root::dtPolyRef,
            pathCount: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_finalizeSlicedFindPath(self, path, pathCount, maxPath)
        }
        #[inline]
        pub unsafe fn finalizeSlicedFindPathPartial(
            &mut self,
            existing: *const root::dtPolyRef,
            existingSize: ::std::os::raw::c_int,
            path: *mut root::dtPolyRef,
            pathCount: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_finalizeSlicedFindPathPartial(
                self,
                existing,
                existingSize,
                path,
                pathCount,
                maxPath,
            )
        }
        #[inline]
        pub unsafe fn findPolysAroundCircle(
            &self,
            startRef: root::dtPolyRef,
            centerPos: *const f32,
            radius: f32,
            filter: *const root::dtQueryFilter,
            resultRef: *mut root::dtPolyRef,
            resultParent: *mut root::dtPolyRef,
            resultCost: *mut f32,
            resultCount: *mut ::std::os::raw::c_int,
            maxResult: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_findPolysAroundCircle(
                self,
                startRef,
                centerPos,
                radius,
                filter,
                resultRef,
                resultParent,
                resultCost,
                resultCount,
                maxResult,
            )
        }
        #[inline]
        pub unsafe fn findPolysAroundShape(
            &self,
            startRef: root::dtPolyRef,
            verts: *const f32,
            nverts: ::std::os::raw::c_int,
            filter: *const root::dtQueryFilter,
            resultRef: *mut root::dtPolyRef,
            resultParent: *mut root::dtPolyRef,
            resultCost: *mut f32,
            resultCount: *mut ::std::os::raw::c_int,
            maxResult: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_findPolysAroundShape(
                self,
                startRef,
                verts,
                nverts,
                filter,
                resultRef,
                resultParent,
                resultCost,
                resultCount,
                maxResult,
            )
        }
        #[inline]
        pub unsafe fn getPathFromDijkstraSearch(
            &self,
            endRef: root::dtPolyRef,
            path: *mut root::dtPolyRef,
            pathCount: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_getPathFromDijkstraSearch(self, endRef, path, pathCount, maxPath)
        }
        #[inline]
        pub unsafe fn findNearestPoly(
            &self,
            center: *const f32,
            halfExtents: *const f32,
            filter: *const root::dtQueryFilter,
            nearestRef: *mut root::dtPolyRef,
            nearestPt: *mut f32,
        ) -> root::dtStatus {
            dtNavMeshQuery_findNearestPoly(self, center, halfExtents, filter, nearestRef, nearestPt)
        }
        #[inline]
        pub unsafe fn findNearestPoly1(
            &self,
            center: *const f32,
            halfExtents: *const f32,
            filter: *const root::dtQueryFilter,
            nearestRef: *mut root::dtPolyRef,
            nearestPt: *mut f32,
            isOverPoly: *mut bool,
        ) -> root::dtStatus {
            dtNavMeshQuery_findNearestPoly1(
                self,
                center,
                halfExtents,
                filter,
                nearestRef,
                nearestPt,
                isOverPoly,
            )
        }
        #[inline]
        pub unsafe fn queryPolygons(
            &self,
            center: *const f32,
            halfExtents: *const f32,
            filter: *const root::dtQueryFilter,
            polys: *mut root::dtPolyRef,
            polyCount: *mut ::std::os::raw::c_int,
            maxPolys: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_queryPolygons(
                self,
                center,
                halfExtents,
                filter,
                polys,
                polyCount,
                maxPolys,
            )
        }
        #[inline]
        pub unsafe fn queryPolygons1(
            &self,
            center: *const f32,
            halfExtents: *const f32,
            filter: *const root::dtQueryFilter,
            query: *mut root::dtPolyQuery,
        ) -> root::dtStatus {
            dtNavMeshQuery_queryPolygons1(self, center, halfExtents, filter, query)
        }
        #[inline]
        pub unsafe fn findLocalNeighbourhood(
            &self,
            startRef: root::dtPolyRef,
            centerPos: *const f32,
            radius: f32,
            filter: *const root::dtQueryFilter,
            resultRef: *mut root::dtPolyRef,
            resultParent: *mut root::dtPolyRef,
            resultCount: *mut ::std::os::raw::c_int,
            maxResult: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_findLocalNeighbourhood(
                self,
                startRef,
                centerPos,
                radius,
                filter,
                resultRef,
                resultParent,
                resultCount,
                maxResult,
            )
        }
        #[inline]
        pub unsafe fn moveAlongSurface(
            &self,
            startRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
            resultPos: *mut f32,
            visited: *mut root::dtPolyRef,
            visitedCount: *mut ::std::os::raw::c_int,
            maxVisitedSize: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_moveAlongSurface(
                self,
                startRef,
                startPos,
                endPos,
                filter,
                resultPos,
                visited,
                visitedCount,
                maxVisitedSize,
            )
        }
        #[inline]
        pub unsafe fn raycast(
            &self,
            startRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
            t: *mut f32,
            hitNormal: *mut f32,
            path: *mut root::dtPolyRef,
            pathCount: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_raycast(
                self, startRef, startPos, endPos, filter, t, hitNormal, path, pathCount, maxPath,
            )
        }
        #[inline]
        pub unsafe fn raycast1(
            &self,
            startRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
            options: ::std::os::raw::c_uint,
            hit: *mut root::dtRaycastHit,
            prevRef: root::dtPolyRef,
        ) -> root::dtStatus {
            dtNavMeshQuery_raycast1(
                self, startRef, startPos, endPos, filter, options, hit, prevRef,
            )
        }
        #[inline]
        pub unsafe fn findDistanceToWall(
            &self,
            startRef: root::dtPolyRef,
            centerPos: *const f32,
            maxRadius: f32,
            filter: *const root::dtQueryFilter,
            hitDist: *mut f32,
            hitPos: *mut f32,
            hitNormal: *mut f32,
        ) -> root::dtStatus {
            dtNavMeshQuery_findDistanceToWall(
                self, startRef, centerPos, maxRadius, filter, hitDist, hitPos, hitNormal,
            )
        }
        #[inline]
        pub unsafe fn getPolyWallSegments(
            &self,
            ref_: root::dtPolyRef,
            filter: *const root::dtQueryFilter,
            segmentVerts: *mut f32,
            segmentRefs: *mut root::dtPolyRef,
            segmentCount: *mut ::std::os::raw::c_int,
            maxSegments: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtNavMeshQuery_getPolyWallSegments(
                self,
                ref_,
                filter,
                segmentVerts,
                segmentRefs,
                segmentCount,
                maxSegments,
            )
        }
        #[inline]
        pub unsafe fn findRandomPoint(
            &self,
            filter: *const root::dtQueryFilter,
            frand: ::std::option::Option<unsafe extern "C" fn() -> f32>,
            randomRef: *mut root::dtPolyRef,
            randomPt: *mut f32,
        ) -> root::dtStatus {
            dtNavMeshQuery_findRandomPoint(self, filter, frand, randomRef, randomPt)
        }
        #[inline]
        pub unsafe fn findRandomPointAroundCircle(
            &self,
            startRef: root::dtPolyRef,
            centerPos: *const f32,
            maxRadius: f32,
            filter: *const root::dtQueryFilter,
            frand: ::std::option::Option<unsafe extern "C" fn() -> f32>,
            randomRef: *mut root::dtPolyRef,
            randomPt: *mut f32,
        ) -> root::dtStatus {
            dtNavMeshQuery_findRandomPointAroundCircle(
                self, startRef, centerPos, maxRadius, filter, frand, randomRef, randomPt,
            )
        }
        #[inline]
        pub unsafe fn closestPointOnPoly(
            &self,
            ref_: root::dtPolyRef,
            pos: *const f32,
            closest: *mut f32,
            posOverPoly: *mut bool,
        ) -> root::dtStatus {
            dtNavMeshQuery_closestPointOnPoly(self, ref_, pos, closest, posOverPoly)
        }
        #[inline]
        pub unsafe fn closestPointOnPolyBoundary(
            &self,
            ref_: root::dtPolyRef,
            pos: *const f32,
            closest: *mut f32,
        ) -> root::dtStatus {
            dtNavMeshQuery_closestPointOnPolyBoundary(self, ref_, pos, closest)
        }
        #[inline]
        pub unsafe fn getPolyHeight(
            &self,
            ref_: root::dtPolyRef,
            pos: *const f32,
            height: *mut f32,
        ) -> root::dtStatus {
            dtNavMeshQuery_getPolyHeight(self, ref_, pos, height)
        }
        #[inline]
        pub unsafe fn isValidPolyRef(
            &self,
            ref_: root::dtPolyRef,
            filter: *const root::dtQueryFilter,
        ) -> bool {
            dtNavMeshQuery_isValidPolyRef(self, ref_, filter)
        }
        #[inline]
        pub unsafe fn isInClosedList(&self, ref_: root::dtPolyRef) -> bool {
            dtNavMeshQuery_isInClosedList(self, ref_)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtNavMeshQuery_dtNavMeshQuery(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            dtNavMeshQuery_dtNavMeshQuery_destructor(self)
        }
    }
    unsafe extern "C" {
        #[doc = " Allocates a query object using the Detour allocator.\n @return An allocated query object, or null on failure.\n @ingroup detour"]
        #[link_name = "\u{1}?dtAllocNavMeshQuery@@YAPEAVdtNavMeshQuery@@XZ"]
        pub fn dtAllocNavMeshQuery() -> *mut root::dtNavMeshQuery;
    }
    unsafe extern "C" {
        #[doc = " Frees the specified query object using the Detour allocator.\n  @param[in]\t\tquery\t\tA query object allocated using #dtAllocNavMeshQuery\n @ingroup detour"]
        #[link_name = "\u{1}?dtFreeNavMeshQuery@@YAXPEAVdtNavMeshQuery@@@Z"]
        pub fn dtFreeNavMeshQuery(query: *mut root::dtNavMeshQuery);
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtObstacleCircle {
        #[doc = "< Position of the obstacle"]
        pub p: [f32; 3usize],
        #[doc = "< Velocity of the obstacle"]
        pub vel: [f32; 3usize],
        #[doc = "< Velocity of the obstacle"]
        pub dvel: [f32; 3usize],
        #[doc = "< Radius of the obstacle"]
        pub rad: f32,
        #[doc = "< Use for side selection during sampling."]
        pub dp: [f32; 3usize],
        #[doc = "< Use for side selection during sampling."]
        pub np: [f32; 3usize],
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtObstacleCircle"][::std::mem::size_of::<dtObstacleCircle>() - 64usize];
        ["Alignment of dtObstacleCircle"][::std::mem::align_of::<dtObstacleCircle>() - 4usize];
        ["Offset of field: dtObstacleCircle::p"]
            [::std::mem::offset_of!(dtObstacleCircle, p) - 0usize];
        ["Offset of field: dtObstacleCircle::vel"]
            [::std::mem::offset_of!(dtObstacleCircle, vel) - 12usize];
        ["Offset of field: dtObstacleCircle::dvel"]
            [::std::mem::offset_of!(dtObstacleCircle, dvel) - 24usize];
        ["Offset of field: dtObstacleCircle::rad"]
            [::std::mem::offset_of!(dtObstacleCircle, rad) - 36usize];
        ["Offset of field: dtObstacleCircle::dp"]
            [::std::mem::offset_of!(dtObstacleCircle, dp) - 40usize];
        ["Offset of field: dtObstacleCircle::np"]
            [::std::mem::offset_of!(dtObstacleCircle, np) - 52usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtObstacleSegment {
        #[doc = "< End points of the obstacle segment"]
        pub p: [f32; 3usize],
        #[doc = "< End points of the obstacle segment"]
        pub q: [f32; 3usize],
        pub touch: bool,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtObstacleSegment"][::std::mem::size_of::<dtObstacleSegment>() - 28usize];
        ["Alignment of dtObstacleSegment"][::std::mem::align_of::<dtObstacleSegment>() - 4usize];
        ["Offset of field: dtObstacleSegment::p"]
            [::std::mem::offset_of!(dtObstacleSegment, p) - 0usize];
        ["Offset of field: dtObstacleSegment::q"]
            [::std::mem::offset_of!(dtObstacleSegment, q) - 12usize];
        ["Offset of field: dtObstacleSegment::touch"]
            [::std::mem::offset_of!(dtObstacleSegment, touch) - 24usize];
    };
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtObstacleAvoidanceDebugData {
        pub m_nsamples: ::std::os::raw::c_int,
        pub m_maxSamples: ::std::os::raw::c_int,
        pub m_vel: *mut f32,
        pub m_ssize: *mut f32,
        pub m_pen: *mut f32,
        pub m_vpen: *mut f32,
        pub m_vcpen: *mut f32,
        pub m_spen: *mut f32,
        pub m_tpen: *mut f32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtObstacleAvoidanceDebugData"]
            [::std::mem::size_of::<dtObstacleAvoidanceDebugData>() - 64usize];
        ["Alignment of dtObstacleAvoidanceDebugData"]
            [::std::mem::align_of::<dtObstacleAvoidanceDebugData>() - 8usize];
        ["Offset of field: dtObstacleAvoidanceDebugData::m_nsamples"]
            [::std::mem::offset_of!(dtObstacleAvoidanceDebugData, m_nsamples) - 0usize];
        ["Offset of field: dtObstacleAvoidanceDebugData::m_maxSamples"]
            [::std::mem::offset_of!(dtObstacleAvoidanceDebugData, m_maxSamples) - 4usize];
        ["Offset of field: dtObstacleAvoidanceDebugData::m_vel"]
            [::std::mem::offset_of!(dtObstacleAvoidanceDebugData, m_vel) - 8usize];
        ["Offset of field: dtObstacleAvoidanceDebugData::m_ssize"]
            [::std::mem::offset_of!(dtObstacleAvoidanceDebugData, m_ssize) - 16usize];
        ["Offset of field: dtObstacleAvoidanceDebugData::m_pen"]
            [::std::mem::offset_of!(dtObstacleAvoidanceDebugData, m_pen) - 24usize];
        ["Offset of field: dtObstacleAvoidanceDebugData::m_vpen"]
            [::std::mem::offset_of!(dtObstacleAvoidanceDebugData, m_vpen) - 32usize];
        ["Offset of field: dtObstacleAvoidanceDebugData::m_vcpen"]
            [::std::mem::offset_of!(dtObstacleAvoidanceDebugData, m_vcpen) - 40usize];
        ["Offset of field: dtObstacleAvoidanceDebugData::m_spen"]
            [::std::mem::offset_of!(dtObstacleAvoidanceDebugData, m_spen) - 48usize];
        ["Offset of field: dtObstacleAvoidanceDebugData::m_tpen"]
            [::std::mem::offset_of!(dtObstacleAvoidanceDebugData, m_tpen) - 56usize];
    };
    unsafe extern "C" {
        #[link_name = "\u{1}?init@dtObstacleAvoidanceDebugData@@QEAA_NH@Z"]
        pub fn dtObstacleAvoidanceDebugData_init(
            this: *mut root::dtObstacleAvoidanceDebugData,
            maxSamples: ::std::os::raw::c_int,
        ) -> bool;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?reset@dtObstacleAvoidanceDebugData@@QEAAXXZ"]
        pub fn dtObstacleAvoidanceDebugData_reset(this: *mut root::dtObstacleAvoidanceDebugData);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?addSample@dtObstacleAvoidanceDebugData@@QEAAXPEBMMMMMMM@Z"]
        pub fn dtObstacleAvoidanceDebugData_addSample(
            this: *mut root::dtObstacleAvoidanceDebugData,
            vel: *const f32,
            ssize: f32,
            pen: f32,
            vpen: f32,
            vcpen: f32,
            spen: f32,
            tpen: f32,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?normalizeSamples@dtObstacleAvoidanceDebugData@@QEAAXXZ"]
        pub fn dtObstacleAvoidanceDebugData_normalizeSamples(
            this: *mut root::dtObstacleAvoidanceDebugData,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtObstacleAvoidanceDebugData@@QEAA@XZ"]
        pub fn dtObstacleAvoidanceDebugData_dtObstacleAvoidanceDebugData(
            this: *mut root::dtObstacleAvoidanceDebugData,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtObstacleAvoidanceDebugData@@QEAA@XZ"]
        pub fn dtObstacleAvoidanceDebugData_dtObstacleAvoidanceDebugData_destructor(
            this: *mut root::dtObstacleAvoidanceDebugData,
        );
    }
    impl dtObstacleAvoidanceDebugData {
        #[inline]
        pub unsafe fn init(&mut self, maxSamples: ::std::os::raw::c_int) -> bool {
            dtObstacleAvoidanceDebugData_init(self, maxSamples)
        }
        #[inline]
        pub unsafe fn reset(&mut self) {
            dtObstacleAvoidanceDebugData_reset(self)
        }
        #[inline]
        pub unsafe fn addSample(
            &mut self,
            vel: *const f32,
            ssize: f32,
            pen: f32,
            vpen: f32,
            vcpen: f32,
            spen: f32,
            tpen: f32,
        ) {
            dtObstacleAvoidanceDebugData_addSample(self, vel, ssize, pen, vpen, vcpen, spen, tpen)
        }
        #[inline]
        pub unsafe fn normalizeSamples(&mut self) {
            dtObstacleAvoidanceDebugData_normalizeSamples(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtObstacleAvoidanceDebugData_dtObstacleAvoidanceDebugData(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            dtObstacleAvoidanceDebugData_dtObstacleAvoidanceDebugData_destructor(self)
        }
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtAllocObstacleAvoidanceDebugData@@YAPEAVdtObstacleAvoidanceDebugData@@XZ"]
        pub fn dtAllocObstacleAvoidanceDebugData() -> *mut root::dtObstacleAvoidanceDebugData;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtFreeObstacleAvoidanceDebugData@@YAXPEAVdtObstacleAvoidanceDebugData@@@Z"]
        pub fn dtFreeObstacleAvoidanceDebugData(ptr: *mut root::dtObstacleAvoidanceDebugData);
    }
    #[doc = "< Max numver of adaptive divs."]
    pub const DT_MAX_PATTERN_DIVS: ::std::os::raw::c_int = 32;
    #[doc = "< Max number of adaptive rings."]
    pub const DT_MAX_PATTERN_RINGS: ::std::os::raw::c_int = 4;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtObstacleAvoidanceParams {
        pub velBias: f32,
        pub weightDesVel: f32,
        pub weightCurVel: f32,
        pub weightSide: f32,
        pub weightToi: f32,
        pub horizTime: f32,
        #[doc = "< grid"]
        pub gridSize: ::std::os::raw::c_uchar,
        #[doc = "< adaptive"]
        pub adaptiveDivs: ::std::os::raw::c_uchar,
        #[doc = "< adaptive"]
        pub adaptiveRings: ::std::os::raw::c_uchar,
        #[doc = "< adaptive"]
        pub adaptiveDepth: ::std::os::raw::c_uchar,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtObstacleAvoidanceParams"]
            [::std::mem::size_of::<dtObstacleAvoidanceParams>() - 28usize];
        ["Alignment of dtObstacleAvoidanceParams"]
            [::std::mem::align_of::<dtObstacleAvoidanceParams>() - 4usize];
        ["Offset of field: dtObstacleAvoidanceParams::velBias"]
            [::std::mem::offset_of!(dtObstacleAvoidanceParams, velBias) - 0usize];
        ["Offset of field: dtObstacleAvoidanceParams::weightDesVel"]
            [::std::mem::offset_of!(dtObstacleAvoidanceParams, weightDesVel) - 4usize];
        ["Offset of field: dtObstacleAvoidanceParams::weightCurVel"]
            [::std::mem::offset_of!(dtObstacleAvoidanceParams, weightCurVel) - 8usize];
        ["Offset of field: dtObstacleAvoidanceParams::weightSide"]
            [::std::mem::offset_of!(dtObstacleAvoidanceParams, weightSide) - 12usize];
        ["Offset of field: dtObstacleAvoidanceParams::weightToi"]
            [::std::mem::offset_of!(dtObstacleAvoidanceParams, weightToi) - 16usize];
        ["Offset of field: dtObstacleAvoidanceParams::horizTime"]
            [::std::mem::offset_of!(dtObstacleAvoidanceParams, horizTime) - 20usize];
        ["Offset of field: dtObstacleAvoidanceParams::gridSize"]
            [::std::mem::offset_of!(dtObstacleAvoidanceParams, gridSize) - 24usize];
        ["Offset of field: dtObstacleAvoidanceParams::adaptiveDivs"]
            [::std::mem::offset_of!(dtObstacleAvoidanceParams, adaptiveDivs) - 25usize];
        ["Offset of field: dtObstacleAvoidanceParams::adaptiveRings"]
            [::std::mem::offset_of!(dtObstacleAvoidanceParams, adaptiveRings) - 26usize];
        ["Offset of field: dtObstacleAvoidanceParams::adaptiveDepth"]
            [::std::mem::offset_of!(dtObstacleAvoidanceParams, adaptiveDepth) - 27usize];
    };
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtObstacleAvoidanceQuery {
        pub m_params: root::dtObstacleAvoidanceParams,
        pub m_invHorizTime: f32,
        pub m_vmax: f32,
        pub m_invVmax: f32,
        pub m_maxCircles: ::std::os::raw::c_int,
        pub m_circles: *mut root::dtObstacleCircle,
        pub m_ncircles: ::std::os::raw::c_int,
        pub m_maxSegments: ::std::os::raw::c_int,
        pub m_segments: *mut root::dtObstacleSegment,
        pub m_nsegments: ::std::os::raw::c_int,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtObstacleAvoidanceQuery"]
            [::std::mem::size_of::<dtObstacleAvoidanceQuery>() - 80usize];
        ["Alignment of dtObstacleAvoidanceQuery"]
            [::std::mem::align_of::<dtObstacleAvoidanceQuery>() - 8usize];
        ["Offset of field: dtObstacleAvoidanceQuery::m_params"]
            [::std::mem::offset_of!(dtObstacleAvoidanceQuery, m_params) - 0usize];
        ["Offset of field: dtObstacleAvoidanceQuery::m_invHorizTime"]
            [::std::mem::offset_of!(dtObstacleAvoidanceQuery, m_invHorizTime) - 28usize];
        ["Offset of field: dtObstacleAvoidanceQuery::m_vmax"]
            [::std::mem::offset_of!(dtObstacleAvoidanceQuery, m_vmax) - 32usize];
        ["Offset of field: dtObstacleAvoidanceQuery::m_invVmax"]
            [::std::mem::offset_of!(dtObstacleAvoidanceQuery, m_invVmax) - 36usize];
        ["Offset of field: dtObstacleAvoidanceQuery::m_maxCircles"]
            [::std::mem::offset_of!(dtObstacleAvoidanceQuery, m_maxCircles) - 40usize];
        ["Offset of field: dtObstacleAvoidanceQuery::m_circles"]
            [::std::mem::offset_of!(dtObstacleAvoidanceQuery, m_circles) - 48usize];
        ["Offset of field: dtObstacleAvoidanceQuery::m_ncircles"]
            [::std::mem::offset_of!(dtObstacleAvoidanceQuery, m_ncircles) - 56usize];
        ["Offset of field: dtObstacleAvoidanceQuery::m_maxSegments"]
            [::std::mem::offset_of!(dtObstacleAvoidanceQuery, m_maxSegments) - 60usize];
        ["Offset of field: dtObstacleAvoidanceQuery::m_segments"]
            [::std::mem::offset_of!(dtObstacleAvoidanceQuery, m_segments) - 64usize];
        ["Offset of field: dtObstacleAvoidanceQuery::m_nsegments"]
            [::std::mem::offset_of!(dtObstacleAvoidanceQuery, m_nsegments) - 72usize];
    };
    unsafe extern "C" {
        #[link_name = "\u{1}?init@dtObstacleAvoidanceQuery@@QEAA_NHH@Z"]
        pub fn dtObstacleAvoidanceQuery_init(
            this: *mut root::dtObstacleAvoidanceQuery,
            maxCircles: ::std::os::raw::c_int,
            maxSegments: ::std::os::raw::c_int,
        ) -> bool;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?reset@dtObstacleAvoidanceQuery@@QEAAXXZ"]
        pub fn dtObstacleAvoidanceQuery_reset(this: *mut root::dtObstacleAvoidanceQuery);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?addCircle@dtObstacleAvoidanceQuery@@QEAAXPEBMM00@Z"]
        pub fn dtObstacleAvoidanceQuery_addCircle(
            this: *mut root::dtObstacleAvoidanceQuery,
            pos: *const f32,
            rad: f32,
            vel: *const f32,
            dvel: *const f32,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?addSegment@dtObstacleAvoidanceQuery@@QEAAXPEBM0@Z"]
        pub fn dtObstacleAvoidanceQuery_addSegment(
            this: *mut root::dtObstacleAvoidanceQuery,
            p: *const f32,
            q: *const f32,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?sampleVelocityGrid@dtObstacleAvoidanceQuery@@QEAAHPEBMMM00PEAMPEBUdtObstacleAvoidanceParams@@PEAVdtObstacleAvoidanceDebugData@@@Z"]
        pub fn dtObstacleAvoidanceQuery_sampleVelocityGrid(
            this: *mut root::dtObstacleAvoidanceQuery,
            pos: *const f32,
            rad: f32,
            vmax: f32,
            vel: *const f32,
            dvel: *const f32,
            nvel: *mut f32,
            params: *const root::dtObstacleAvoidanceParams,
            debug: *mut root::dtObstacleAvoidanceDebugData,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?sampleVelocityAdaptive@dtObstacleAvoidanceQuery@@QEAAHPEBMMM00PEAMPEBUdtObstacleAvoidanceParams@@PEAVdtObstacleAvoidanceDebugData@@@Z"]
        pub fn dtObstacleAvoidanceQuery_sampleVelocityAdaptive(
            this: *mut root::dtObstacleAvoidanceQuery,
            pos: *const f32,
            rad: f32,
            vmax: f32,
            vel: *const f32,
            dvel: *const f32,
            nvel: *mut f32,
            params: *const root::dtObstacleAvoidanceParams,
            debug: *mut root::dtObstacleAvoidanceDebugData,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtObstacleAvoidanceQuery@@QEAA@XZ"]
        pub fn dtObstacleAvoidanceQuery_dtObstacleAvoidanceQuery(
            this: *mut root::dtObstacleAvoidanceQuery,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtObstacleAvoidanceQuery@@QEAA@XZ"]
        pub fn dtObstacleAvoidanceQuery_dtObstacleAvoidanceQuery_destructor(
            this: *mut root::dtObstacleAvoidanceQuery,
        );
    }
    impl dtObstacleAvoidanceQuery {
        #[inline]
        pub unsafe fn init(
            &mut self,
            maxCircles: ::std::os::raw::c_int,
            maxSegments: ::std::os::raw::c_int,
        ) -> bool {
            dtObstacleAvoidanceQuery_init(self, maxCircles, maxSegments)
        }
        #[inline]
        pub unsafe fn reset(&mut self) {
            dtObstacleAvoidanceQuery_reset(self)
        }
        #[inline]
        pub unsafe fn addCircle(
            &mut self,
            pos: *const f32,
            rad: f32,
            vel: *const f32,
            dvel: *const f32,
        ) {
            dtObstacleAvoidanceQuery_addCircle(self, pos, rad, vel, dvel)
        }
        #[inline]
        pub unsafe fn addSegment(&mut self, p: *const f32, q: *const f32) {
            dtObstacleAvoidanceQuery_addSegment(self, p, q)
        }
        #[inline]
        pub unsafe fn sampleVelocityGrid(
            &mut self,
            pos: *const f32,
            rad: f32,
            vmax: f32,
            vel: *const f32,
            dvel: *const f32,
            nvel: *mut f32,
            params: *const root::dtObstacleAvoidanceParams,
            debug: *mut root::dtObstacleAvoidanceDebugData,
        ) -> ::std::os::raw::c_int {
            dtObstacleAvoidanceQuery_sampleVelocityGrid(
                self, pos, rad, vmax, vel, dvel, nvel, params, debug,
            )
        }
        #[inline]
        pub unsafe fn sampleVelocityAdaptive(
            &mut self,
            pos: *const f32,
            rad: f32,
            vmax: f32,
            vel: *const f32,
            dvel: *const f32,
            nvel: *mut f32,
            params: *const root::dtObstacleAvoidanceParams,
            debug: *mut root::dtObstacleAvoidanceDebugData,
        ) -> ::std::os::raw::c_int {
            dtObstacleAvoidanceQuery_sampleVelocityAdaptive(
                self, pos, rad, vmax, vel, dvel, nvel, params, debug,
            )
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtObstacleAvoidanceQuery_dtObstacleAvoidanceQuery(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            dtObstacleAvoidanceQuery_dtObstacleAvoidanceQuery_destructor(self)
        }
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtAllocObstacleAvoidanceQuery@@YAPEAVdtObstacleAvoidanceQuery@@XZ"]
        pub fn dtAllocObstacleAvoidanceQuery() -> *mut root::dtObstacleAvoidanceQuery;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtFreeObstacleAvoidanceQuery@@YAXPEAVdtObstacleAvoidanceQuery@@@Z"]
        pub fn dtFreeObstacleAvoidanceQuery(ptr: *mut root::dtObstacleAvoidanceQuery);
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtLocalBoundary {
        pub m_center: [f32; 3usize],
        pub m_segs: [root::dtLocalBoundary_Segment; 8usize],
        pub m_nsegs: ::std::os::raw::c_int,
        pub m_polys: [root::dtPolyRef; 16usize],
        pub m_npolys: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtLocalBoundary_Segment {
        #[doc = "< Segment start/end"]
        pub s: [f32; 6usize],
        #[doc = "< Distance for pruning."]
        pub d: f32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtLocalBoundary_Segment"]
            [::std::mem::size_of::<dtLocalBoundary_Segment>() - 28usize];
        ["Alignment of dtLocalBoundary_Segment"]
            [::std::mem::align_of::<dtLocalBoundary_Segment>() - 4usize];
        ["Offset of field: dtLocalBoundary_Segment::s"]
            [::std::mem::offset_of!(dtLocalBoundary_Segment, s) - 0usize];
        ["Offset of field: dtLocalBoundary_Segment::d"]
            [::std::mem::offset_of!(dtLocalBoundary_Segment, d) - 24usize];
    };
    pub const dtLocalBoundary_MAX_LOCAL_SEGS: ::std::os::raw::c_int = 8;
    pub const dtLocalBoundary_MAX_LOCAL_POLYS: ::std::os::raw::c_int = 16;
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtLocalBoundary"][::std::mem::size_of::<dtLocalBoundary>() - 308usize];
        ["Alignment of dtLocalBoundary"][::std::mem::align_of::<dtLocalBoundary>() - 4usize];
        ["Offset of field: dtLocalBoundary::m_center"]
            [::std::mem::offset_of!(dtLocalBoundary, m_center) - 0usize];
        ["Offset of field: dtLocalBoundary::m_segs"]
            [::std::mem::offset_of!(dtLocalBoundary, m_segs) - 12usize];
        ["Offset of field: dtLocalBoundary::m_nsegs"]
            [::std::mem::offset_of!(dtLocalBoundary, m_nsegs) - 236usize];
        ["Offset of field: dtLocalBoundary::m_polys"]
            [::std::mem::offset_of!(dtLocalBoundary, m_polys) - 240usize];
        ["Offset of field: dtLocalBoundary::m_npolys"]
            [::std::mem::offset_of!(dtLocalBoundary, m_npolys) - 304usize];
    };
    unsafe extern "C" {
        #[link_name = "\u{1}?reset@dtLocalBoundary@@QEAAXXZ"]
        pub fn dtLocalBoundary_reset(this: *mut root::dtLocalBoundary);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?update@dtLocalBoundary@@QEAAXIPEBMMPEAVdtNavMeshQuery@@PEBVdtQueryFilter@@@Z"]
        pub fn dtLocalBoundary_update(
            this: *mut root::dtLocalBoundary,
            ref_: root::dtPolyRef,
            pos: *const f32,
            collisionQueryRange: f32,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?isValid@dtLocalBoundary@@QEAA_NPEAVdtNavMeshQuery@@PEBVdtQueryFilter@@@Z"]
        pub fn dtLocalBoundary_isValid(
            this: *mut root::dtLocalBoundary,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtLocalBoundary@@QEAA@XZ"]
        pub fn dtLocalBoundary_dtLocalBoundary(this: *mut root::dtLocalBoundary);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtLocalBoundary@@QEAA@XZ"]
        pub fn dtLocalBoundary_dtLocalBoundary_destructor(this: *mut root::dtLocalBoundary);
    }
    impl dtLocalBoundary {
        #[inline]
        pub unsafe fn reset(&mut self) {
            dtLocalBoundary_reset(self)
        }
        #[inline]
        pub unsafe fn update(
            &mut self,
            ref_: root::dtPolyRef,
            pos: *const f32,
            collisionQueryRange: f32,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) {
            dtLocalBoundary_update(self, ref_, pos, collisionQueryRange, navquery, filter)
        }
        #[inline]
        pub unsafe fn isValid(
            &mut self,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool {
            dtLocalBoundary_isValid(self, navquery, filter)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtLocalBoundary_dtLocalBoundary(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            dtLocalBoundary_dtLocalBoundary_destructor(self)
        }
    }
    #[doc = " Represents a dynamic polygon corridor used to plan agent movement.\n @ingroup crowd, detour"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtPathCorridor {
        pub m_pos: [f32; 3usize],
        pub m_target: [f32; 3usize],
        pub m_path: *mut root::dtPolyRef,
        pub m_npath: ::std::os::raw::c_int,
        pub m_maxPath: ::std::os::raw::c_int,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtPathCorridor"][::std::mem::size_of::<dtPathCorridor>() - 40usize];
        ["Alignment of dtPathCorridor"][::std::mem::align_of::<dtPathCorridor>() - 8usize];
        ["Offset of field: dtPathCorridor::m_pos"]
            [::std::mem::offset_of!(dtPathCorridor, m_pos) - 0usize];
        ["Offset of field: dtPathCorridor::m_target"]
            [::std::mem::offset_of!(dtPathCorridor, m_target) - 12usize];
        ["Offset of field: dtPathCorridor::m_path"]
            [::std::mem::offset_of!(dtPathCorridor, m_path) - 24usize];
        ["Offset of field: dtPathCorridor::m_npath"]
            [::std::mem::offset_of!(dtPathCorridor, m_npath) - 32usize];
        ["Offset of field: dtPathCorridor::m_maxPath"]
            [::std::mem::offset_of!(dtPathCorridor, m_maxPath) - 36usize];
    };
    unsafe extern "C" {
        #[doc = " Allocates the corridor's path buffer.\n  @param[in]\t\tmaxPath\t\tThe maximum path size the corridor can handle.\n @return True if the initialization succeeded."]
        #[link_name = "\u{1}?init@dtPathCorridor@@QEAA_NH@Z"]
        pub fn dtPathCorridor_init(
            this: *mut root::dtPathCorridor,
            maxPath: ::std::os::raw::c_int,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Resets the path corridor to the specified position.\n  @param[in]\t\tref\t\tThe polygon reference containing the position.\n  @param[in]\t\tpos\t\tThe new position in the corridor. [(x, y, z)]"]
        #[link_name = "\u{1}?reset@dtPathCorridor@@QEAAXIPEBM@Z"]
        pub fn dtPathCorridor_reset(
            this: *mut root::dtPathCorridor,
            ref_: root::dtPolyRef,
            pos: *const f32,
        );
    }
    unsafe extern "C" {
        #[doc = " Finds the corners in the corridor from the position toward the target. (The straightened path.)\n  @param[out]\tcornerVerts\t\tThe corner vertices. [(x, y, z) * cornerCount] [Size: <= maxCorners]\n  @param[out]\tcornerFlags\t\tThe flag for each corner. [(flag) * cornerCount] [Size: <= maxCorners]\n  @param[out]\tcornerPolys\t\tThe polygon reference for each corner. [(polyRef) * cornerCount]\n  \t\t\t\t\t\t\t\t[Size: <= @p maxCorners]\n  @param[in]\t\tmaxCorners\t\tThe maximum number of corners the buffers can hold.\n  @param[in]\t\tnavquery\t\tThe query object used to build the corridor.\n  @param[in]\t\tfilter\t\t\tThe filter to apply to the operation.\n @return The number of corners returned in the corner buffers. [0 <= value <= @p maxCorners]"]
        #[link_name = "\u{1}?findCorners@dtPathCorridor@@QEAAHPEAMPEAEPEAIHPEAVdtNavMeshQuery@@PEBVdtQueryFilter@@@Z"]
        pub fn dtPathCorridor_findCorners(
            this: *mut root::dtPathCorridor,
            cornerVerts: *mut f32,
            cornerFlags: *mut ::std::os::raw::c_uchar,
            cornerPolys: *mut root::dtPolyRef,
            maxCorners: ::std::os::raw::c_int,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[doc = " Attempts to optimize the path if the specified point is visible from the current position.\n  @param[in]\t\tnext\t\t\t\t\tThe point to search toward. [(x, y, z])\n  @param[in]\t\tpathOptimizationRange\tThe maximum range to search. [Limit: > 0]\n  @param[in]\t\tnavquery\t\t\t\tThe query object used to build the corridor.\n  @param[in]\t\tfilter\t\t\t\t\tThe filter to apply to the operation."]
        #[link_name = "\u{1}?optimizePathVisibility@dtPathCorridor@@QEAAXPEBMMPEAVdtNavMeshQuery@@PEBVdtQueryFilter@@@Z"]
        pub fn dtPathCorridor_optimizePathVisibility(
            this: *mut root::dtPathCorridor,
            next: *const f32,
            pathOptimizationRange: f32,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        );
    }
    unsafe extern "C" {
        #[doc = " Attempts to optimize the path using a local area search. (Partial replanning.)\n  @param[in]\t\tnavquery\tThe query object used to build the corridor.\n  @param[in]\t\tfilter\t\tThe filter to apply to the operation."]
        #[link_name = "\u{1}?optimizePathTopology@dtPathCorridor@@QEAA_NPEAVdtNavMeshQuery@@PEBVdtQueryFilter@@@Z"]
        pub fn dtPathCorridor_optimizePathTopology(
            this: *mut root::dtPathCorridor,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?moveOverOffmeshConnection@dtPathCorridor@@QEAA_NIPEAIPEAM1PEAVdtNavMeshQuery@@@Z"]
        pub fn dtPathCorridor_moveOverOffmeshConnection(
            this: *mut root::dtPathCorridor,
            offMeshConRef: root::dtPolyRef,
            refs: *mut root::dtPolyRef,
            startPos: *mut f32,
            endPos: *mut f32,
            navquery: *mut root::dtNavMeshQuery,
        ) -> bool;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?fixPathStart@dtPathCorridor@@QEAA_NIPEBM@Z"]
        pub fn dtPathCorridor_fixPathStart(
            this: *mut root::dtPathCorridor,
            safeRef: root::dtPolyRef,
            safePos: *const f32,
        ) -> bool;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?trimInvalidPath@dtPathCorridor@@QEAA_NIPEBMPEAVdtNavMeshQuery@@PEBVdtQueryFilter@@@Z"]
        pub fn dtPathCorridor_trimInvalidPath(
            this: *mut root::dtPathCorridor,
            safeRef: root::dtPolyRef,
            safePos: *const f32,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Checks the current corridor path to see if its polygon references remain valid.\n  @param[in]\t\tmaxLookAhead\tThe number of polygons from the beginning of the corridor to search.\n  @param[in]\t\tnavquery\t\tThe query object used to build the corridor.\n  @param[in]\t\tfilter\t\t\tThe filter to apply to the operation."]
        #[link_name = "\u{1}?isValid@dtPathCorridor@@QEAA_NHPEAVdtNavMeshQuery@@PEBVdtQueryFilter@@@Z"]
        pub fn dtPathCorridor_isValid(
            this: *mut root::dtPathCorridor,
            maxLookAhead: ::std::os::raw::c_int,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Moves the position from the current location to the desired location, adjusting the corridor\n as needed to reflect the change.\n  @param[in]\t\tnpos\t\tThe desired new position. [(x, y, z)]\n  @param[in]\t\tnavquery\tThe query object used to build the corridor.\n  @param[in]\t\tfilter\t\tThe filter to apply to the operation.\n @return Returns true if move succeeded."]
        #[link_name = "\u{1}?movePosition@dtPathCorridor@@QEAA_NPEBMPEAVdtNavMeshQuery@@PEBVdtQueryFilter@@@Z"]
        pub fn dtPathCorridor_movePosition(
            this: *mut root::dtPathCorridor,
            npos: *const f32,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Moves the target from the curent location to the desired location, adjusting the corridor\n as needed to reflect the change.\n  @param[in]\t\tnpos\t\tThe desired new target position. [(x, y, z)]\n  @param[in]\t\tnavquery\tThe query object used to build the corridor.\n  @param[in]\t\tfilter\t\tThe filter to apply to the operation.\n @return Returns true if move succeeded."]
        #[link_name = "\u{1}?moveTargetPosition@dtPathCorridor@@QEAA_NPEBMPEAVdtNavMeshQuery@@PEBVdtQueryFilter@@@Z"]
        pub fn dtPathCorridor_moveTargetPosition(
            this: *mut root::dtPathCorridor,
            npos: *const f32,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Loads a new path and target into the corridor.\n  @param[in]\t\ttarget\t\tThe target location within the last polygon of the path. [(x, y, z)]\n  @param[in]\t\tpath\t\tThe path corridor. [(polyRef) * @p npolys]\n  @param[in]\t\tnpath\t\tThe number of polygons in the path."]
        #[link_name = "\u{1}?setCorridor@dtPathCorridor@@QEAAXPEBMPEBIH@Z"]
        pub fn dtPathCorridor_setCorridor(
            this: *mut root::dtPathCorridor,
            target: *const f32,
            polys: *const root::dtPolyRef,
            npath: ::std::os::raw::c_int,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtPathCorridor@@QEAA@XZ"]
        pub fn dtPathCorridor_dtPathCorridor(this: *mut root::dtPathCorridor);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtPathCorridor@@QEAA@XZ"]
        pub fn dtPathCorridor_dtPathCorridor_destructor(this: *mut root::dtPathCorridor);
    }
    impl dtPathCorridor {
        #[inline]
        pub unsafe fn init(&mut self, maxPath: ::std::os::raw::c_int) -> bool {
            dtPathCorridor_init(self, maxPath)
        }
        #[inline]
        pub unsafe fn reset(&mut self, ref_: root::dtPolyRef, pos: *const f32) {
            dtPathCorridor_reset(self, ref_, pos)
        }
        #[inline]
        pub unsafe fn findCorners(
            &mut self,
            cornerVerts: *mut f32,
            cornerFlags: *mut ::std::os::raw::c_uchar,
            cornerPolys: *mut root::dtPolyRef,
            maxCorners: ::std::os::raw::c_int,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> ::std::os::raw::c_int {
            dtPathCorridor_findCorners(
                self,
                cornerVerts,
                cornerFlags,
                cornerPolys,
                maxCorners,
                navquery,
                filter,
            )
        }
        #[inline]
        pub unsafe fn optimizePathVisibility(
            &mut self,
            next: *const f32,
            pathOptimizationRange: f32,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) {
            dtPathCorridor_optimizePathVisibility(
                self,
                next,
                pathOptimizationRange,
                navquery,
                filter,
            )
        }
        #[inline]
        pub unsafe fn optimizePathTopology(
            &mut self,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool {
            dtPathCorridor_optimizePathTopology(self, navquery, filter)
        }
        #[inline]
        pub unsafe fn moveOverOffmeshConnection(
            &mut self,
            offMeshConRef: root::dtPolyRef,
            refs: *mut root::dtPolyRef,
            startPos: *mut f32,
            endPos: *mut f32,
            navquery: *mut root::dtNavMeshQuery,
        ) -> bool {
            dtPathCorridor_moveOverOffmeshConnection(
                self,
                offMeshConRef,
                refs,
                startPos,
                endPos,
                navquery,
            )
        }
        #[inline]
        pub unsafe fn fixPathStart(
            &mut self,
            safeRef: root::dtPolyRef,
            safePos: *const f32,
        ) -> bool {
            dtPathCorridor_fixPathStart(self, safeRef, safePos)
        }
        #[inline]
        pub unsafe fn trimInvalidPath(
            &mut self,
            safeRef: root::dtPolyRef,
            safePos: *const f32,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool {
            dtPathCorridor_trimInvalidPath(self, safeRef, safePos, navquery, filter)
        }
        #[inline]
        pub unsafe fn isValid(
            &mut self,
            maxLookAhead: ::std::os::raw::c_int,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool {
            dtPathCorridor_isValid(self, maxLookAhead, navquery, filter)
        }
        #[inline]
        pub unsafe fn movePosition(
            &mut self,
            npos: *const f32,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool {
            dtPathCorridor_movePosition(self, npos, navquery, filter)
        }
        #[inline]
        pub unsafe fn moveTargetPosition(
            &mut self,
            npos: *const f32,
            navquery: *mut root::dtNavMeshQuery,
            filter: *const root::dtQueryFilter,
        ) -> bool {
            dtPathCorridor_moveTargetPosition(self, npos, navquery, filter)
        }
        #[inline]
        pub unsafe fn setCorridor(
            &mut self,
            target: *const f32,
            polys: *const root::dtPolyRef,
            npath: ::std::os::raw::c_int,
        ) {
            dtPathCorridor_setCorridor(self, target, polys, npath)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtPathCorridor_dtPathCorridor(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            dtPathCorridor_dtPathCorridor_destructor(self)
        }
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtMergeCorridorStartMoved@@YAHPEAIHHPEBIH@Z"]
        pub fn dtMergeCorridorStartMoved(
            path: *mut root::dtPolyRef,
            npath: ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
            visited: *const root::dtPolyRef,
            nvisited: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtMergeCorridorEndMoved@@YAHPEAIHHPEBIH@Z"]
        pub fn dtMergeCorridorEndMoved(
            path: *mut root::dtPolyRef,
            npath: ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
            visited: *const root::dtPolyRef,
            nvisited: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtMergeCorridorStartShortcut@@YAHPEAIHHPEBIH@Z"]
        pub fn dtMergeCorridorStartShortcut(
            path: *mut root::dtPolyRef,
            npath: ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
            visited: *const root::dtPolyRef,
            nvisited: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtProximityGrid {
        pub m_cellSize: f32,
        pub m_invCellSize: f32,
        pub m_pool: *mut root::dtProximityGrid_Item,
        pub m_poolHead: ::std::os::raw::c_int,
        pub m_poolSize: ::std::os::raw::c_int,
        pub m_buckets: *mut ::std::os::raw::c_ushort,
        pub m_bucketsSize: ::std::os::raw::c_int,
        pub m_bounds: [::std::os::raw::c_int; 4usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtProximityGrid_Item {
        pub id: ::std::os::raw::c_ushort,
        pub x: ::std::os::raw::c_short,
        pub y: ::std::os::raw::c_short,
        pub next: ::std::os::raw::c_ushort,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtProximityGrid_Item"][::std::mem::size_of::<dtProximityGrid_Item>() - 8usize];
        ["Alignment of dtProximityGrid_Item"]
            [::std::mem::align_of::<dtProximityGrid_Item>() - 2usize];
        ["Offset of field: dtProximityGrid_Item::id"]
            [::std::mem::offset_of!(dtProximityGrid_Item, id) - 0usize];
        ["Offset of field: dtProximityGrid_Item::x"]
            [::std::mem::offset_of!(dtProximityGrid_Item, x) - 2usize];
        ["Offset of field: dtProximityGrid_Item::y"]
            [::std::mem::offset_of!(dtProximityGrid_Item, y) - 4usize];
        ["Offset of field: dtProximityGrid_Item::next"]
            [::std::mem::offset_of!(dtProximityGrid_Item, next) - 6usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtProximityGrid"][::std::mem::size_of::<dtProximityGrid>() - 56usize];
        ["Alignment of dtProximityGrid"][::std::mem::align_of::<dtProximityGrid>() - 8usize];
        ["Offset of field: dtProximityGrid::m_cellSize"]
            [::std::mem::offset_of!(dtProximityGrid, m_cellSize) - 0usize];
        ["Offset of field: dtProximityGrid::m_invCellSize"]
            [::std::mem::offset_of!(dtProximityGrid, m_invCellSize) - 4usize];
        ["Offset of field: dtProximityGrid::m_pool"]
            [::std::mem::offset_of!(dtProximityGrid, m_pool) - 8usize];
        ["Offset of field: dtProximityGrid::m_poolHead"]
            [::std::mem::offset_of!(dtProximityGrid, m_poolHead) - 16usize];
        ["Offset of field: dtProximityGrid::m_poolSize"]
            [::std::mem::offset_of!(dtProximityGrid, m_poolSize) - 20usize];
        ["Offset of field: dtProximityGrid::m_buckets"]
            [::std::mem::offset_of!(dtProximityGrid, m_buckets) - 24usize];
        ["Offset of field: dtProximityGrid::m_bucketsSize"]
            [::std::mem::offset_of!(dtProximityGrid, m_bucketsSize) - 32usize];
        ["Offset of field: dtProximityGrid::m_bounds"]
            [::std::mem::offset_of!(dtProximityGrid, m_bounds) - 36usize];
    };
    unsafe extern "C" {
        #[link_name = "\u{1}?init@dtProximityGrid@@QEAA_NHM@Z"]
        pub fn dtProximityGrid_init(
            this: *mut root::dtProximityGrid,
            poolSize: ::std::os::raw::c_int,
            cellSize: f32,
        ) -> bool;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?clear@dtProximityGrid@@QEAAXXZ"]
        pub fn dtProximityGrid_clear(this: *mut root::dtProximityGrid);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?addItem@dtProximityGrid@@QEAAXGMMMM@Z"]
        pub fn dtProximityGrid_addItem(
            this: *mut root::dtProximityGrid,
            id: ::std::os::raw::c_ushort,
            minx: f32,
            miny: f32,
            maxx: f32,
            maxy: f32,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?queryItems@dtProximityGrid@@QEBAHMMMMPEAGH@Z"]
        pub fn dtProximityGrid_queryItems(
            this: *const root::dtProximityGrid,
            minx: f32,
            miny: f32,
            maxx: f32,
            maxy: f32,
            ids: *mut ::std::os::raw::c_ushort,
            maxIds: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?getItemCountAt@dtProximityGrid@@QEBAHHH@Z"]
        pub fn dtProximityGrid_getItemCountAt(
            this: *const root::dtProximityGrid,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtProximityGrid@@QEAA@XZ"]
        pub fn dtProximityGrid_dtProximityGrid(this: *mut root::dtProximityGrid);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtProximityGrid@@QEAA@XZ"]
        pub fn dtProximityGrid_dtProximityGrid_destructor(this: *mut root::dtProximityGrid);
    }
    impl dtProximityGrid {
        #[inline]
        pub unsafe fn init(&mut self, poolSize: ::std::os::raw::c_int, cellSize: f32) -> bool {
            dtProximityGrid_init(self, poolSize, cellSize)
        }
        #[inline]
        pub unsafe fn clear(&mut self) {
            dtProximityGrid_clear(self)
        }
        #[inline]
        pub unsafe fn addItem(
            &mut self,
            id: ::std::os::raw::c_ushort,
            minx: f32,
            miny: f32,
            maxx: f32,
            maxy: f32,
        ) {
            dtProximityGrid_addItem(self, id, minx, miny, maxx, maxy)
        }
        #[inline]
        pub unsafe fn queryItems(
            &self,
            minx: f32,
            miny: f32,
            maxx: f32,
            maxy: f32,
            ids: *mut ::std::os::raw::c_ushort,
            maxIds: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            dtProximityGrid_queryItems(self, minx, miny, maxx, maxy, ids, maxIds)
        }
        #[inline]
        pub unsafe fn getItemCountAt(
            &self,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            dtProximityGrid_getItemCountAt(self, x, y)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtProximityGrid_dtProximityGrid(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            dtProximityGrid_dtProximityGrid_destructor(self)
        }
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtAllocProximityGrid@@YAPEAVdtProximityGrid@@XZ"]
        pub fn dtAllocProximityGrid() -> *mut root::dtProximityGrid;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtFreeProximityGrid@@YAXPEAVdtProximityGrid@@@Z"]
        pub fn dtFreeProximityGrid(ptr: *mut root::dtProximityGrid);
    }
    pub const DT_PATHQ_INVALID: ::std::os::raw::c_uint = 0;
    pub type dtPathQueueRef = ::std::os::raw::c_uint;
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtPathQueue {
        pub m_queue: [root::dtPathQueue_PathQuery; 8usize],
        pub m_nextHandle: root::dtPathQueueRef,
        pub m_maxPathSize: ::std::os::raw::c_int,
        pub m_queueHead: ::std::os::raw::c_int,
        pub m_navquery: *mut root::dtNavMeshQuery,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtPathQueue_PathQuery {
        pub ref_: root::dtPathQueueRef,
        #[doc = " Path find start and end location."]
        pub startPos: [f32; 3usize],
        #[doc = " Path find start and end location."]
        pub endPos: [f32; 3usize],
        pub startRef: root::dtPolyRef,
        pub endRef: root::dtPolyRef,
        #[doc = " Result."]
        pub path: *mut root::dtPolyRef,
        pub npath: ::std::os::raw::c_int,
        #[doc = " State."]
        pub status: root::dtStatus,
        pub keepAlive: ::std::os::raw::c_int,
        #[doc = "< TODO: This is potentially dangerous!"]
        pub filter: *const root::dtQueryFilter,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtPathQueue_PathQuery"][::std::mem::size_of::<dtPathQueue_PathQuery>() - 72usize];
        ["Alignment of dtPathQueue_PathQuery"]
            [::std::mem::align_of::<dtPathQueue_PathQuery>() - 8usize];
        ["Offset of field: dtPathQueue_PathQuery::ref_"]
            [::std::mem::offset_of!(dtPathQueue_PathQuery, ref_) - 0usize];
        ["Offset of field: dtPathQueue_PathQuery::startPos"]
            [::std::mem::offset_of!(dtPathQueue_PathQuery, startPos) - 4usize];
        ["Offset of field: dtPathQueue_PathQuery::endPos"]
            [::std::mem::offset_of!(dtPathQueue_PathQuery, endPos) - 16usize];
        ["Offset of field: dtPathQueue_PathQuery::startRef"]
            [::std::mem::offset_of!(dtPathQueue_PathQuery, startRef) - 28usize];
        ["Offset of field: dtPathQueue_PathQuery::endRef"]
            [::std::mem::offset_of!(dtPathQueue_PathQuery, endRef) - 32usize];
        ["Offset of field: dtPathQueue_PathQuery::path"]
            [::std::mem::offset_of!(dtPathQueue_PathQuery, path) - 40usize];
        ["Offset of field: dtPathQueue_PathQuery::npath"]
            [::std::mem::offset_of!(dtPathQueue_PathQuery, npath) - 48usize];
        ["Offset of field: dtPathQueue_PathQuery::status"]
            [::std::mem::offset_of!(dtPathQueue_PathQuery, status) - 52usize];
        ["Offset of field: dtPathQueue_PathQuery::keepAlive"]
            [::std::mem::offset_of!(dtPathQueue_PathQuery, keepAlive) - 56usize];
        ["Offset of field: dtPathQueue_PathQuery::filter"]
            [::std::mem::offset_of!(dtPathQueue_PathQuery, filter) - 64usize];
    };
    pub const dtPathQueue_MAX_QUEUE: ::std::os::raw::c_int = 8;
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtPathQueue"][::std::mem::size_of::<dtPathQueue>() - 600usize];
        ["Alignment of dtPathQueue"][::std::mem::align_of::<dtPathQueue>() - 8usize];
        ["Offset of field: dtPathQueue::m_queue"]
            [::std::mem::offset_of!(dtPathQueue, m_queue) - 0usize];
        ["Offset of field: dtPathQueue::m_nextHandle"]
            [::std::mem::offset_of!(dtPathQueue, m_nextHandle) - 576usize];
        ["Offset of field: dtPathQueue::m_maxPathSize"]
            [::std::mem::offset_of!(dtPathQueue, m_maxPathSize) - 580usize];
        ["Offset of field: dtPathQueue::m_queueHead"]
            [::std::mem::offset_of!(dtPathQueue, m_queueHead) - 584usize];
        ["Offset of field: dtPathQueue::m_navquery"]
            [::std::mem::offset_of!(dtPathQueue, m_navquery) - 592usize];
    };
    unsafe extern "C" {
        #[link_name = "\u{1}?init@dtPathQueue@@QEAA_NHHPEAVdtNavMesh@@@Z"]
        pub fn dtPathQueue_init(
            this: *mut root::dtPathQueue,
            maxPathSize: ::std::os::raw::c_int,
            maxSearchNodeCount: ::std::os::raw::c_int,
            nav: *mut root::dtNavMesh,
        ) -> bool;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?update@dtPathQueue@@QEAAXH@Z"]
        pub fn dtPathQueue_update(this: *mut root::dtPathQueue, maxIters: ::std::os::raw::c_int);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?request@dtPathQueue@@QEAAIIIPEBM0PEBVdtQueryFilter@@@Z"]
        pub fn dtPathQueue_request(
            this: *mut root::dtPathQueue,
            startRef: root::dtPolyRef,
            endRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
        ) -> root::dtPathQueueRef;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?getRequestStatus@dtPathQueue@@QEBAII@Z"]
        pub fn dtPathQueue_getRequestStatus(
            this: *const root::dtPathQueue,
            ref_: root::dtPathQueueRef,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?getPathResult@dtPathQueue@@QEAAIIPEAIPEAHH@Z"]
        pub fn dtPathQueue_getPathResult(
            this: *mut root::dtPathQueue,
            ref_: root::dtPathQueueRef,
            path: *mut root::dtPolyRef,
            pathSize: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtPathQueue@@QEAA@XZ"]
        pub fn dtPathQueue_dtPathQueue(this: *mut root::dtPathQueue);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtPathQueue@@QEAA@XZ"]
        pub fn dtPathQueue_dtPathQueue_destructor(this: *mut root::dtPathQueue);
    }
    impl dtPathQueue {
        #[inline]
        pub unsafe fn init(
            &mut self,
            maxPathSize: ::std::os::raw::c_int,
            maxSearchNodeCount: ::std::os::raw::c_int,
            nav: *mut root::dtNavMesh,
        ) -> bool {
            dtPathQueue_init(self, maxPathSize, maxSearchNodeCount, nav)
        }
        #[inline]
        pub unsafe fn update(&mut self, maxIters: ::std::os::raw::c_int) {
            dtPathQueue_update(self, maxIters)
        }
        #[inline]
        pub unsafe fn request(
            &mut self,
            startRef: root::dtPolyRef,
            endRef: root::dtPolyRef,
            startPos: *const f32,
            endPos: *const f32,
            filter: *const root::dtQueryFilter,
        ) -> root::dtPathQueueRef {
            dtPathQueue_request(self, startRef, endRef, startPos, endPos, filter)
        }
        #[inline]
        pub unsafe fn getRequestStatus(&self, ref_: root::dtPathQueueRef) -> root::dtStatus {
            dtPathQueue_getRequestStatus(self, ref_)
        }
        #[inline]
        pub unsafe fn getPathResult(
            &mut self,
            ref_: root::dtPathQueueRef,
            path: *mut root::dtPolyRef,
            pathSize: *mut ::std::os::raw::c_int,
            maxPath: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtPathQueue_getPathResult(self, ref_, path, pathSize, maxPath)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtPathQueue_dtPathQueue(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            dtPathQueue_dtPathQueue_destructor(self)
        }
    }
    #[doc = " The maximum number of neighbors that a crowd agent can take into account\n for steering decisions.\n @ingroup crowd"]
    pub const DT_CROWDAGENT_MAX_NEIGHBOURS: ::std::os::raw::c_int = 6;
    #[doc = " The maximum number of corners a crowd agent will look ahead in the path.\n This value is used for sizing the crowd agent corner buffers.\n Due to the behavior of the crowd manager, the actual number of useful\n corners will be one less than this number.\n @ingroup crowd"]
    pub const DT_CROWDAGENT_MAX_CORNERS: ::std::os::raw::c_int = 4;
    #[doc = " The maximum number of crowd avoidance configurations supported by the\n crowd manager.\n @ingroup crowd\n @see dtObstacleAvoidanceParams, dtCrowd::setObstacleAvoidanceParams(), dtCrowd::getObstacleAvoidanceParams(),\n\t\t dtCrowdAgentParams::obstacleAvoidanceType"]
    pub const DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS: ::std::os::raw::c_int = 8;
    #[doc = " The maximum number of query filter types supported by the crowd manager.\n @ingroup crowd\n @see dtQueryFilter, dtCrowd::getFilter() dtCrowd::getEditableFilter(),\n\t\tdtCrowdAgentParams::queryFilterType"]
    pub const DT_CROWD_MAX_QUERY_FILTER_TYPE: ::std::os::raw::c_int = 16;
    #[doc = " Provides neighbor data for agents managed by the crowd.\n @ingroup crowd\n @see dtCrowdAgent::neis, dtCrowd"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtCrowdNeighbour {
        #[doc = "< The index of the neighbor in the crowd."]
        pub idx: ::std::os::raw::c_int,
        #[doc = "< The distance between the current agent and the neighbor."]
        pub dist: f32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtCrowdNeighbour"][::std::mem::size_of::<dtCrowdNeighbour>() - 8usize];
        ["Alignment of dtCrowdNeighbour"][::std::mem::align_of::<dtCrowdNeighbour>() - 4usize];
        ["Offset of field: dtCrowdNeighbour::idx"]
            [::std::mem::offset_of!(dtCrowdNeighbour, idx) - 0usize];
        ["Offset of field: dtCrowdNeighbour::dist"]
            [::std::mem::offset_of!(dtCrowdNeighbour, dist) - 4usize];
    };
    #[doc = "< The agent is not in a valid state."]
    pub const CrowdAgentState_DT_CROWDAGENT_STATE_INVALID: CrowdAgentState = 0;
    #[doc = "< The agent is traversing a normal navigation mesh polygon."]
    pub const CrowdAgentState_DT_CROWDAGENT_STATE_WALKING: CrowdAgentState = 1;
    #[doc = "< The agent is traversing an off-mesh connection."]
    pub const CrowdAgentState_DT_CROWDAGENT_STATE_OFFMESH: CrowdAgentState = 2;
    #[doc = " The type of navigation mesh polygon the agent is currently traversing.\n @ingroup crowd"]
    pub type CrowdAgentState = ::std::os::raw::c_int;
    #[doc = " Configuration parameters for a crowd agent.\n @ingroup crowd"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtCrowdAgentParams {
        #[doc = "< Agent radius. [Limit: >= 0]"]
        pub radius: f32,
        #[doc = "< Agent height. [Limit: > 0]"]
        pub height: f32,
        #[doc = "< Maximum allowed acceleration. [Limit: >= 0]"]
        pub maxAcceleration: f32,
        #[doc = "< Maximum allowed speed. [Limit: >= 0]"]
        pub maxSpeed: f32,
        #[doc = " Defines how close a collision element must be before it is considered for steering behaviors. [Limits: > 0]"]
        pub collisionQueryRange: f32,
        #[doc = "< The path visibility optimization range. [Limit: > 0]"]
        pub pathOptimizationRange: f32,
        #[doc = " How aggresive the agent manager should be at avoiding collisions with this agent. [Limit: >= 0]"]
        pub separationWeight: f32,
        #[doc = " Flags that impact steering behavior. (See: #UpdateFlags)"]
        pub updateFlags: ::std::os::raw::c_uchar,
        #[doc = " The index of the avoidance configuration to use for the agent.\n [Limits: 0 <= value <= #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]"]
        pub obstacleAvoidanceType: ::std::os::raw::c_uchar,
        #[doc = " The index of the query filter used by this agent."]
        pub queryFilterType: ::std::os::raw::c_uchar,
        #[doc = " User defined data attached to the agent."]
        pub userData: *mut ::std::os::raw::c_void,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtCrowdAgentParams"][::std::mem::size_of::<dtCrowdAgentParams>() - 40usize];
        ["Alignment of dtCrowdAgentParams"][::std::mem::align_of::<dtCrowdAgentParams>() - 8usize];
        ["Offset of field: dtCrowdAgentParams::radius"]
            [::std::mem::offset_of!(dtCrowdAgentParams, radius) - 0usize];
        ["Offset of field: dtCrowdAgentParams::height"]
            [::std::mem::offset_of!(dtCrowdAgentParams, height) - 4usize];
        ["Offset of field: dtCrowdAgentParams::maxAcceleration"]
            [::std::mem::offset_of!(dtCrowdAgentParams, maxAcceleration) - 8usize];
        ["Offset of field: dtCrowdAgentParams::maxSpeed"]
            [::std::mem::offset_of!(dtCrowdAgentParams, maxSpeed) - 12usize];
        ["Offset of field: dtCrowdAgentParams::collisionQueryRange"]
            [::std::mem::offset_of!(dtCrowdAgentParams, collisionQueryRange) - 16usize];
        ["Offset of field: dtCrowdAgentParams::pathOptimizationRange"]
            [::std::mem::offset_of!(dtCrowdAgentParams, pathOptimizationRange) - 20usize];
        ["Offset of field: dtCrowdAgentParams::separationWeight"]
            [::std::mem::offset_of!(dtCrowdAgentParams, separationWeight) - 24usize];
        ["Offset of field: dtCrowdAgentParams::updateFlags"]
            [::std::mem::offset_of!(dtCrowdAgentParams, updateFlags) - 28usize];
        ["Offset of field: dtCrowdAgentParams::obstacleAvoidanceType"]
            [::std::mem::offset_of!(dtCrowdAgentParams, obstacleAvoidanceType) - 29usize];
        ["Offset of field: dtCrowdAgentParams::queryFilterType"]
            [::std::mem::offset_of!(dtCrowdAgentParams, queryFilterType) - 30usize];
        ["Offset of field: dtCrowdAgentParams::userData"]
            [::std::mem::offset_of!(dtCrowdAgentParams, userData) - 32usize];
    };
    pub const MoveRequestState_DT_CROWDAGENT_TARGET_NONE: MoveRequestState = 0;
    pub const MoveRequestState_DT_CROWDAGENT_TARGET_FAILED: MoveRequestState = 1;
    pub const MoveRequestState_DT_CROWDAGENT_TARGET_VALID: MoveRequestState = 2;
    pub const MoveRequestState_DT_CROWDAGENT_TARGET_REQUESTING: MoveRequestState = 3;
    pub const MoveRequestState_DT_CROWDAGENT_TARGET_WAITING_FOR_QUEUE: MoveRequestState = 4;
    pub const MoveRequestState_DT_CROWDAGENT_TARGET_WAITING_FOR_PATH: MoveRequestState = 5;
    pub const MoveRequestState_DT_CROWDAGENT_TARGET_VELOCITY: MoveRequestState = 6;
    pub type MoveRequestState = ::std::os::raw::c_int;
    #[doc = " Represents an agent managed by a #dtCrowd object.\n @ingroup crowd"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtCrowdAgent {
        #[doc = " True if the agent is active, false if the agent is in an unused slot in the agent pool."]
        pub active: bool,
        #[doc = " The type of mesh polygon the agent is traversing. (See: #CrowdAgentState)"]
        pub state: ::std::os::raw::c_uchar,
        #[doc = " True if the agent has valid path (targetState == DT_CROWDAGENT_TARGET_VALID) and the path does not lead to the requested position, else false."]
        pub partial: bool,
        #[doc = " The path corridor the agent is using."]
        pub corridor: root::dtPathCorridor,
        #[doc = " The local boundary data for the agent."]
        pub boundary: root::dtLocalBoundary,
        #[doc = " Time since the agent's path corridor was optimized."]
        pub topologyOptTime: f32,
        #[doc = " The known neighbors of the agent."]
        pub neis: [root::dtCrowdNeighbour; 6usize],
        #[doc = " The number of neighbors."]
        pub nneis: ::std::os::raw::c_int,
        #[doc = " The desired speed."]
        pub desiredSpeed: f32,
        #[doc = "< The current agent position. [(x, y, z)]"]
        pub npos: [f32; 3usize],
        #[doc = "< A temporary value used to accumulate agent displacement during iterative collision resolution. [(x, y, z)]"]
        pub disp: [f32; 3usize],
        #[doc = "< The desired velocity of the agent. Based on the current path, calculated from scratch each frame. [(x, y, z)]"]
        pub dvel: [f32; 3usize],
        #[doc = "< The desired velocity adjusted by obstacle avoidance, calculated from scratch each frame. [(x, y, z)]"]
        pub nvel: [f32; 3usize],
        #[doc = "< The actual velocity of the agent. The change from nvel -> vel is constrained by max acceleration. [(x, y, z)]"]
        pub vel: [f32; 3usize],
        #[doc = " The agent's configuration parameters."]
        pub params: root::dtCrowdAgentParams,
        #[doc = " The local path corridor corners for the agent. (Staight path.) [(x, y, z) * #ncorners]"]
        pub cornerVerts: [f32; 12usize],
        #[doc = " The local path corridor corner flags. (See: #dtStraightPathFlags) [(flags) * #ncorners]"]
        pub cornerFlags: [::std::os::raw::c_uchar; 4usize],
        #[doc = " The reference id of the polygon being entered at the corner. [(polyRef) * #ncorners]"]
        pub cornerPolys: [root::dtPolyRef; 4usize],
        #[doc = " The number of corners."]
        pub ncorners: ::std::os::raw::c_int,
        #[doc = "< State of the movement request."]
        pub targetState: ::std::os::raw::c_uchar,
        #[doc = "< Target polyref of the movement request."]
        pub targetRef: root::dtPolyRef,
        #[doc = "< Target position of the movement request (or velocity in case of DT_CROWDAGENT_TARGET_VELOCITY)."]
        pub targetPos: [f32; 3usize],
        #[doc = "< Path finder ref."]
        pub targetPathqRef: root::dtPathQueueRef,
        #[doc = "< Flag indicating that the current path is being replanned."]
        pub targetReplan: bool,
        pub targetReplanTime: f32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtCrowdAgent"][::std::mem::size_of::<dtCrowdAgent>() - 624usize];
        ["Alignment of dtCrowdAgent"][::std::mem::align_of::<dtCrowdAgent>() - 8usize];
        ["Offset of field: dtCrowdAgent::active"]
            [::std::mem::offset_of!(dtCrowdAgent, active) - 0usize];
        ["Offset of field: dtCrowdAgent::state"]
            [::std::mem::offset_of!(dtCrowdAgent, state) - 1usize];
        ["Offset of field: dtCrowdAgent::partial"]
            [::std::mem::offset_of!(dtCrowdAgent, partial) - 2usize];
        ["Offset of field: dtCrowdAgent::corridor"]
            [::std::mem::offset_of!(dtCrowdAgent, corridor) - 8usize];
        ["Offset of field: dtCrowdAgent::boundary"]
            [::std::mem::offset_of!(dtCrowdAgent, boundary) - 48usize];
        ["Offset of field: dtCrowdAgent::topologyOptTime"]
            [::std::mem::offset_of!(dtCrowdAgent, topologyOptTime) - 356usize];
        ["Offset of field: dtCrowdAgent::neis"]
            [::std::mem::offset_of!(dtCrowdAgent, neis) - 360usize];
        ["Offset of field: dtCrowdAgent::nneis"]
            [::std::mem::offset_of!(dtCrowdAgent, nneis) - 408usize];
        ["Offset of field: dtCrowdAgent::desiredSpeed"]
            [::std::mem::offset_of!(dtCrowdAgent, desiredSpeed) - 412usize];
        ["Offset of field: dtCrowdAgent::npos"]
            [::std::mem::offset_of!(dtCrowdAgent, npos) - 416usize];
        ["Offset of field: dtCrowdAgent::disp"]
            [::std::mem::offset_of!(dtCrowdAgent, disp) - 428usize];
        ["Offset of field: dtCrowdAgent::dvel"]
            [::std::mem::offset_of!(dtCrowdAgent, dvel) - 440usize];
        ["Offset of field: dtCrowdAgent::nvel"]
            [::std::mem::offset_of!(dtCrowdAgent, nvel) - 452usize];
        ["Offset of field: dtCrowdAgent::vel"]
            [::std::mem::offset_of!(dtCrowdAgent, vel) - 464usize];
        ["Offset of field: dtCrowdAgent::params"]
            [::std::mem::offset_of!(dtCrowdAgent, params) - 480usize];
        ["Offset of field: dtCrowdAgent::cornerVerts"]
            [::std::mem::offset_of!(dtCrowdAgent, cornerVerts) - 520usize];
        ["Offset of field: dtCrowdAgent::cornerFlags"]
            [::std::mem::offset_of!(dtCrowdAgent, cornerFlags) - 568usize];
        ["Offset of field: dtCrowdAgent::cornerPolys"]
            [::std::mem::offset_of!(dtCrowdAgent, cornerPolys) - 572usize];
        ["Offset of field: dtCrowdAgent::ncorners"]
            [::std::mem::offset_of!(dtCrowdAgent, ncorners) - 588usize];
        ["Offset of field: dtCrowdAgent::targetState"]
            [::std::mem::offset_of!(dtCrowdAgent, targetState) - 592usize];
        ["Offset of field: dtCrowdAgent::targetRef"]
            [::std::mem::offset_of!(dtCrowdAgent, targetRef) - 596usize];
        ["Offset of field: dtCrowdAgent::targetPos"]
            [::std::mem::offset_of!(dtCrowdAgent, targetPos) - 600usize];
        ["Offset of field: dtCrowdAgent::targetPathqRef"]
            [::std::mem::offset_of!(dtCrowdAgent, targetPathqRef) - 612usize];
        ["Offset of field: dtCrowdAgent::targetReplan"]
            [::std::mem::offset_of!(dtCrowdAgent, targetReplan) - 616usize];
        ["Offset of field: dtCrowdAgent::targetReplanTime"]
            [::std::mem::offset_of!(dtCrowdAgent, targetReplanTime) - 620usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtCrowdAgentAnimation {
        pub active: bool,
        pub initPos: [f32; 3usize],
        pub startPos: [f32; 3usize],
        pub endPos: [f32; 3usize],
        pub polyRef: root::dtPolyRef,
        pub t: f32,
        pub tmax: f32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtCrowdAgentAnimation"][::std::mem::size_of::<dtCrowdAgentAnimation>() - 52usize];
        ["Alignment of dtCrowdAgentAnimation"]
            [::std::mem::align_of::<dtCrowdAgentAnimation>() - 4usize];
        ["Offset of field: dtCrowdAgentAnimation::active"]
            [::std::mem::offset_of!(dtCrowdAgentAnimation, active) - 0usize];
        ["Offset of field: dtCrowdAgentAnimation::initPos"]
            [::std::mem::offset_of!(dtCrowdAgentAnimation, initPos) - 4usize];
        ["Offset of field: dtCrowdAgentAnimation::startPos"]
            [::std::mem::offset_of!(dtCrowdAgentAnimation, startPos) - 16usize];
        ["Offset of field: dtCrowdAgentAnimation::endPos"]
            [::std::mem::offset_of!(dtCrowdAgentAnimation, endPos) - 28usize];
        ["Offset of field: dtCrowdAgentAnimation::polyRef"]
            [::std::mem::offset_of!(dtCrowdAgentAnimation, polyRef) - 40usize];
        ["Offset of field: dtCrowdAgentAnimation::t"]
            [::std::mem::offset_of!(dtCrowdAgentAnimation, t) - 44usize];
        ["Offset of field: dtCrowdAgentAnimation::tmax"]
            [::std::mem::offset_of!(dtCrowdAgentAnimation, tmax) - 48usize];
    };
    pub const UpdateFlags_DT_CROWD_ANTICIPATE_TURNS: UpdateFlags = 1;
    pub const UpdateFlags_DT_CROWD_OBSTACLE_AVOIDANCE: UpdateFlags = 2;
    pub const UpdateFlags_DT_CROWD_SEPARATION: UpdateFlags = 4;
    #[doc = "< Use #dtPathCorridor::optimizePathVisibility() to optimize the agent path."]
    pub const UpdateFlags_DT_CROWD_OPTIMIZE_VIS: UpdateFlags = 8;
    #[doc = "< Use dtPathCorridor::optimizePathTopology() to optimize the agent path."]
    pub const UpdateFlags_DT_CROWD_OPTIMIZE_TOPO: UpdateFlags = 16;
    #[doc = " Crowd agent update flags.\n @ingroup crowd\n @see dtCrowdAgentParams::updateFlags"]
    pub type UpdateFlags = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtCrowdAgentDebugInfo {
        pub idx: ::std::os::raw::c_int,
        pub optStart: [f32; 3usize],
        pub optEnd: [f32; 3usize],
        pub vod: *mut root::dtObstacleAvoidanceDebugData,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtCrowdAgentDebugInfo"][::std::mem::size_of::<dtCrowdAgentDebugInfo>() - 40usize];
        ["Alignment of dtCrowdAgentDebugInfo"]
            [::std::mem::align_of::<dtCrowdAgentDebugInfo>() - 8usize];
        ["Offset of field: dtCrowdAgentDebugInfo::idx"]
            [::std::mem::offset_of!(dtCrowdAgentDebugInfo, idx) - 0usize];
        ["Offset of field: dtCrowdAgentDebugInfo::optStart"]
            [::std::mem::offset_of!(dtCrowdAgentDebugInfo, optStart) - 4usize];
        ["Offset of field: dtCrowdAgentDebugInfo::optEnd"]
            [::std::mem::offset_of!(dtCrowdAgentDebugInfo, optEnd) - 16usize];
        ["Offset of field: dtCrowdAgentDebugInfo::vod"]
            [::std::mem::offset_of!(dtCrowdAgentDebugInfo, vod) - 32usize];
    };
    #[doc = " Provides local steering behaviors for a group of agents.\n @ingroup crowd"]
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtCrowd {
        pub m_maxAgents: ::std::os::raw::c_int,
        pub m_agents: *mut root::dtCrowdAgent,
        pub m_activeAgents: *mut *mut root::dtCrowdAgent,
        pub m_agentAnims: *mut root::dtCrowdAgentAnimation,
        pub m_pathq: root::dtPathQueue,
        pub m_obstacleQueryParams: [root::dtObstacleAvoidanceParams; 8usize],
        pub m_obstacleQuery: *mut root::dtObstacleAvoidanceQuery,
        pub m_grid: *mut root::dtProximityGrid,
        pub m_pathResult: *mut root::dtPolyRef,
        pub m_maxPathResult: ::std::os::raw::c_int,
        pub m_agentPlacementHalfExtents: [f32; 3usize],
        pub m_filters: [root::dtQueryFilter; 16usize],
        pub m_maxAgentRadius: f32,
        pub m_velocitySampleCount: ::std::os::raw::c_int,
        pub m_navquery: *mut root::dtNavMeshQuery,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtCrowd"][::std::mem::size_of::<dtCrowd>() - 5072usize];
        ["Alignment of dtCrowd"][::std::mem::align_of::<dtCrowd>() - 8usize];
        ["Offset of field: dtCrowd::m_maxAgents"]
            [::std::mem::offset_of!(dtCrowd, m_maxAgents) - 0usize];
        ["Offset of field: dtCrowd::m_agents"][::std::mem::offset_of!(dtCrowd, m_agents) - 8usize];
        ["Offset of field: dtCrowd::m_activeAgents"]
            [::std::mem::offset_of!(dtCrowd, m_activeAgents) - 16usize];
        ["Offset of field: dtCrowd::m_agentAnims"]
            [::std::mem::offset_of!(dtCrowd, m_agentAnims) - 24usize];
        ["Offset of field: dtCrowd::m_pathq"][::std::mem::offset_of!(dtCrowd, m_pathq) - 32usize];
        ["Offset of field: dtCrowd::m_obstacleQueryParams"]
            [::std::mem::offset_of!(dtCrowd, m_obstacleQueryParams) - 632usize];
        ["Offset of field: dtCrowd::m_obstacleQuery"]
            [::std::mem::offset_of!(dtCrowd, m_obstacleQuery) - 856usize];
        ["Offset of field: dtCrowd::m_grid"][::std::mem::offset_of!(dtCrowd, m_grid) - 864usize];
        ["Offset of field: dtCrowd::m_pathResult"]
            [::std::mem::offset_of!(dtCrowd, m_pathResult) - 872usize];
        ["Offset of field: dtCrowd::m_maxPathResult"]
            [::std::mem::offset_of!(dtCrowd, m_maxPathResult) - 880usize];
        ["Offset of field: dtCrowd::m_agentPlacementHalfExtents"]
            [::std::mem::offset_of!(dtCrowd, m_agentPlacementHalfExtents) - 884usize];
        ["Offset of field: dtCrowd::m_filters"]
            [::std::mem::offset_of!(dtCrowd, m_filters) - 896usize];
        ["Offset of field: dtCrowd::m_maxAgentRadius"]
            [::std::mem::offset_of!(dtCrowd, m_maxAgentRadius) - 5056usize];
        ["Offset of field: dtCrowd::m_velocitySampleCount"]
            [::std::mem::offset_of!(dtCrowd, m_velocitySampleCount) - 5060usize];
        ["Offset of field: dtCrowd::m_navquery"]
            [::std::mem::offset_of!(dtCrowd, m_navquery) - 5064usize];
    };
    unsafe extern "C" {
        #[doc = " Initializes the crowd.\n  @param[in]\t\tmaxAgents\t\tThe maximum number of agents the crowd can manage. [Limit: >= 1]\n  @param[in]\t\tmaxAgentRadius\tThe maximum radius of any agent that will be added to the crowd. [Limit: > 0]\n  @param[in]\t\tnav\t\t\t\tThe navigation mesh to use for planning.\n @return True if the initialization succeeded."]
        #[link_name = "\u{1}?init@dtCrowd@@QEAA_NHMPEAVdtNavMesh@@@Z"]
        pub fn dtCrowd_init(
            this: *mut root::dtCrowd,
            maxAgents: ::std::os::raw::c_int,
            maxAgentRadius: f32,
            nav: *mut root::dtNavMesh,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Sets the shared avoidance configuration for the specified index.\n  @param[in]\t\tidx\t\tThe index. [Limits: 0 <= value < #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]\n  @param[in]\t\tparams\tThe new configuration."]
        #[link_name = "\u{1}?setObstacleAvoidanceParams@dtCrowd@@QEAAXHPEBUdtObstacleAvoidanceParams@@@Z"]
        pub fn dtCrowd_setObstacleAvoidanceParams(
            this: *mut root::dtCrowd,
            idx: ::std::os::raw::c_int,
            params: *const root::dtObstacleAvoidanceParams,
        );
    }
    unsafe extern "C" {
        #[doc = " Gets the shared avoidance configuration for the specified index.\n  @param[in]\t\tidx\t\tThe index of the configuration to retreive.\n\t\t\t\t\t\t\t[Limits:  0 <= value < #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]\n @return The requested configuration."]
        #[link_name = "\u{1}?getObstacleAvoidanceParams@dtCrowd@@QEBAPEBUdtObstacleAvoidanceParams@@H@Z"]
        pub fn dtCrowd_getObstacleAvoidanceParams(
            this: *const root::dtCrowd,
            idx: ::std::os::raw::c_int,
        ) -> *const root::dtObstacleAvoidanceParams;
    }
    unsafe extern "C" {
        #[doc = " Gets the specified agent from the pool.\n\t @param[in]\t\tidx\t\tThe agent index. [Limits: 0 <= value < #getAgentCount()]\n @return The requested agent."]
        #[link_name = "\u{1}?getAgent@dtCrowd@@QEAAPEBUdtCrowdAgent@@H@Z"]
        pub fn dtCrowd_getAgent(
            this: *mut root::dtCrowd,
            idx: ::std::os::raw::c_int,
        ) -> *const root::dtCrowdAgent;
    }
    unsafe extern "C" {
        #[doc = " Gets the specified agent from the pool.\n\t @param[in]\t\tidx\t\tThe agent index. [Limits: 0 <= value < #getAgentCount()]\n @return The requested agent."]
        #[link_name = "\u{1}?getEditableAgent@dtCrowd@@QEAAPEAUdtCrowdAgent@@H@Z"]
        pub fn dtCrowd_getEditableAgent(
            this: *mut root::dtCrowd,
            idx: ::std::os::raw::c_int,
        ) -> *mut root::dtCrowdAgent;
    }
    unsafe extern "C" {
        #[doc = " The maximum number of agents that can be managed by the object.\n @return The maximum number of agents."]
        #[link_name = "\u{1}?getAgentCount@dtCrowd@@QEBAHXZ"]
        pub fn dtCrowd_getAgentCount(this: *const root::dtCrowd) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[doc = " Adds a new agent to the crowd.\n  @param[in]\t\tpos\t\tThe requested position of the agent. [(x, y, z)]\n  @param[in]\t\tparams\tThe configuration of the agent.\n @return The index of the agent in the agent pool. Or -1 if the agent could not be added."]
        #[link_name = "\u{1}?addAgent@dtCrowd@@QEAAHPEBMPEBUdtCrowdAgentParams@@@Z"]
        pub fn dtCrowd_addAgent(
            this: *mut root::dtCrowd,
            pos: *const f32,
            params: *const root::dtCrowdAgentParams,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[doc = " Updates the specified agent's configuration.\n  @param[in]\t\tidx\t\tThe agent index. [Limits: 0 <= value < #getAgentCount()]\n  @param[in]\t\tparams\tThe new agent configuration."]
        #[link_name = "\u{1}?updateAgentParameters@dtCrowd@@QEAAXHPEBUdtCrowdAgentParams@@@Z"]
        pub fn dtCrowd_updateAgentParameters(
            this: *mut root::dtCrowd,
            idx: ::std::os::raw::c_int,
            params: *const root::dtCrowdAgentParams,
        );
    }
    unsafe extern "C" {
        #[doc = " Removes the agent from the crowd.\n  @param[in]\t\tidx\t\tThe agent index. [Limits: 0 <= value < #getAgentCount()]"]
        #[link_name = "\u{1}?removeAgent@dtCrowd@@QEAAXH@Z"]
        pub fn dtCrowd_removeAgent(this: *mut root::dtCrowd, idx: ::std::os::raw::c_int);
    }
    unsafe extern "C" {
        #[doc = " Submits a new move request for the specified agent.\n  @param[in]\t\tidx\t\tThe agent index. [Limits: 0 <= value < #getAgentCount()]\n  @param[in]\t\tref\t\tThe position's polygon reference.\n  @param[in]\t\tpos\t\tThe position within the polygon. [(x, y, z)]\n @return True if the request was successfully submitted."]
        #[link_name = "\u{1}?requestMoveTarget@dtCrowd@@QEAA_NHIPEBM@Z"]
        pub fn dtCrowd_requestMoveTarget(
            this: *mut root::dtCrowd,
            idx: ::std::os::raw::c_int,
            ref_: root::dtPolyRef,
            pos: *const f32,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Submits a new move request for the specified agent.\n  @param[in]\t\tidx\t\tThe agent index. [Limits: 0 <= value < #getAgentCount()]\n  @param[in]\t\tvel\t\tThe movement velocity. [(x, y, z)]\n @return True if the request was successfully submitted."]
        #[link_name = "\u{1}?requestMoveVelocity@dtCrowd@@QEAA_NHPEBM@Z"]
        pub fn dtCrowd_requestMoveVelocity(
            this: *mut root::dtCrowd,
            idx: ::std::os::raw::c_int,
            vel: *const f32,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Resets any request for the specified agent.\n  @param[in]\t\tidx\t\tThe agent index. [Limits: 0 <= value < #getAgentCount()]\n @return True if the request was successfully reseted."]
        #[link_name = "\u{1}?resetMoveTarget@dtCrowd@@QEAA_NH@Z"]
        pub fn dtCrowd_resetMoveTarget(
            this: *mut root::dtCrowd,
            idx: ::std::os::raw::c_int,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Gets the active agents int the agent pool.\n  @param[out]\tagents\t\tAn array of agent pointers. [(#dtCrowdAgent *) * maxAgents]\n  @param[in]\t\tmaxAgents\tThe size of the crowd agent array.\n @return The number of agents returned in @p agents."]
        #[link_name = "\u{1}?getActiveAgents@dtCrowd@@QEAAHPEAPEAUdtCrowdAgent@@H@Z"]
        pub fn dtCrowd_getActiveAgents(
            this: *mut root::dtCrowd,
            agents: *mut *mut root::dtCrowdAgent,
            maxAgents: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[doc = " Updates the steering and positions of all agents.\n  @param[in]\t\tdt\t\tThe time, in seconds, to update the simulation. [Limit: > 0]\n  @param[out]\tdebug\tA debug object to load with debug information. [Opt]"]
        #[link_name = "\u{1}?update@dtCrowd@@QEAAXMPEAUdtCrowdAgentDebugInfo@@@Z"]
        pub fn dtCrowd_update(
            this: *mut root::dtCrowd,
            dt: f32,
            debug: *mut root::dtCrowdAgentDebugInfo,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtCrowd@@QEAA@XZ"]
        pub fn dtCrowd_dtCrowd(this: *mut root::dtCrowd);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtCrowd@@QEAA@XZ"]
        pub fn dtCrowd_dtCrowd_destructor(this: *mut root::dtCrowd);
    }
    impl dtCrowd {
        #[inline]
        pub unsafe fn init(
            &mut self,
            maxAgents: ::std::os::raw::c_int,
            maxAgentRadius: f32,
            nav: *mut root::dtNavMesh,
        ) -> bool {
            dtCrowd_init(self, maxAgents, maxAgentRadius, nav)
        }
        #[inline]
        pub unsafe fn setObstacleAvoidanceParams(
            &mut self,
            idx: ::std::os::raw::c_int,
            params: *const root::dtObstacleAvoidanceParams,
        ) {
            dtCrowd_setObstacleAvoidanceParams(self, idx, params)
        }
        #[inline]
        pub unsafe fn getObstacleAvoidanceParams(
            &self,
            idx: ::std::os::raw::c_int,
        ) -> *const root::dtObstacleAvoidanceParams {
            dtCrowd_getObstacleAvoidanceParams(self, idx)
        }
        #[inline]
        pub unsafe fn getAgent(&mut self, idx: ::std::os::raw::c_int) -> *const root::dtCrowdAgent {
            dtCrowd_getAgent(self, idx)
        }
        #[inline]
        pub unsafe fn getEditableAgent(
            &mut self,
            idx: ::std::os::raw::c_int,
        ) -> *mut root::dtCrowdAgent {
            dtCrowd_getEditableAgent(self, idx)
        }
        #[inline]
        pub unsafe fn getAgentCount(&self) -> ::std::os::raw::c_int {
            dtCrowd_getAgentCount(self)
        }
        #[inline]
        pub unsafe fn addAgent(
            &mut self,
            pos: *const f32,
            params: *const root::dtCrowdAgentParams,
        ) -> ::std::os::raw::c_int {
            dtCrowd_addAgent(self, pos, params)
        }
        #[inline]
        pub unsafe fn updateAgentParameters(
            &mut self,
            idx: ::std::os::raw::c_int,
            params: *const root::dtCrowdAgentParams,
        ) {
            dtCrowd_updateAgentParameters(self, idx, params)
        }
        #[inline]
        pub unsafe fn removeAgent(&mut self, idx: ::std::os::raw::c_int) {
            dtCrowd_removeAgent(self, idx)
        }
        #[inline]
        pub unsafe fn requestMoveTarget(
            &mut self,
            idx: ::std::os::raw::c_int,
            ref_: root::dtPolyRef,
            pos: *const f32,
        ) -> bool {
            dtCrowd_requestMoveTarget(self, idx, ref_, pos)
        }
        #[inline]
        pub unsafe fn requestMoveVelocity(
            &mut self,
            idx: ::std::os::raw::c_int,
            vel: *const f32,
        ) -> bool {
            dtCrowd_requestMoveVelocity(self, idx, vel)
        }
        #[inline]
        pub unsafe fn resetMoveTarget(&mut self, idx: ::std::os::raw::c_int) -> bool {
            dtCrowd_resetMoveTarget(self, idx)
        }
        #[inline]
        pub unsafe fn getActiveAgents(
            &mut self,
            agents: *mut *mut root::dtCrowdAgent,
            maxAgents: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            dtCrowd_getActiveAgents(self, agents, maxAgents)
        }
        #[inline]
        pub unsafe fn update(&mut self, dt: f32, debug: *mut root::dtCrowdAgentDebugInfo) {
            dtCrowd_update(self, dt, debug)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtCrowd_dtCrowd(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            dtCrowd_dtCrowd_destructor(self)
        }
    }
    unsafe extern "C" {
        #[doc = " Allocates a crowd object using the Detour allocator.\n @return A crowd object that is ready for initialization, or null on failure.\n  @ingroup crowd"]
        #[link_name = "\u{1}?dtAllocCrowd@@YAPEAVdtCrowd@@XZ"]
        pub fn dtAllocCrowd() -> *mut root::dtCrowd;
    }
    unsafe extern "C" {
        #[doc = " Frees the specified crowd object using the Detour allocator.\n  @param[in]\t\tptr\t\tA crowd object allocated using #dtAllocCrowd\n  @ingroup crowd"]
        #[link_name = "\u{1}?dtFreeCrowd@@YAXPEAVdtCrowd@@@Z"]
        pub fn dtFreeCrowd(ptr: *mut root::dtCrowd);
    }
    pub type dtObstacleRef = ::std::os::raw::c_uint;
    pub type dtCompressedTileRef = ::std::os::raw::c_uint;
    #[doc = "< Navmesh owns the tile memory and should free it."]
    pub const dtCompressedTileFlags_DT_COMPRESSEDTILE_FREE_DATA: dtCompressedTileFlags = 1;
    #[doc = " Flags for addTile"]
    pub type dtCompressedTileFlags = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtCompressedTile {
        #[doc = "< Counter describing modifications to the tile."]
        pub salt: ::std::os::raw::c_uint,
        pub header: *mut root::dtTileCacheLayerHeader,
        pub compressed: *mut ::std::os::raw::c_uchar,
        pub compressedSize: ::std::os::raw::c_int,
        pub data: *mut ::std::os::raw::c_uchar,
        pub dataSize: ::std::os::raw::c_int,
        pub flags: ::std::os::raw::c_uint,
        pub next: *mut root::dtCompressedTile,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtCompressedTile"][::std::mem::size_of::<dtCompressedTile>() - 56usize];
        ["Alignment of dtCompressedTile"][::std::mem::align_of::<dtCompressedTile>() - 8usize];
        ["Offset of field: dtCompressedTile::salt"]
            [::std::mem::offset_of!(dtCompressedTile, salt) - 0usize];
        ["Offset of field: dtCompressedTile::header"]
            [::std::mem::offset_of!(dtCompressedTile, header) - 8usize];
        ["Offset of field: dtCompressedTile::compressed"]
            [::std::mem::offset_of!(dtCompressedTile, compressed) - 16usize];
        ["Offset of field: dtCompressedTile::compressedSize"]
            [::std::mem::offset_of!(dtCompressedTile, compressedSize) - 24usize];
        ["Offset of field: dtCompressedTile::data"]
            [::std::mem::offset_of!(dtCompressedTile, data) - 32usize];
        ["Offset of field: dtCompressedTile::dataSize"]
            [::std::mem::offset_of!(dtCompressedTile, dataSize) - 40usize];
        ["Offset of field: dtCompressedTile::flags"]
            [::std::mem::offset_of!(dtCompressedTile, flags) - 44usize];
        ["Offset of field: dtCompressedTile::next"]
            [::std::mem::offset_of!(dtCompressedTile, next) - 48usize];
    };
    pub const ObstacleState_DT_OBSTACLE_EMPTY: ObstacleState = 0;
    pub const ObstacleState_DT_OBSTACLE_PROCESSING: ObstacleState = 1;
    pub const ObstacleState_DT_OBSTACLE_PROCESSED: ObstacleState = 2;
    pub const ObstacleState_DT_OBSTACLE_REMOVING: ObstacleState = 3;
    pub type ObstacleState = ::std::os::raw::c_int;
    pub const ObstacleType_DT_OBSTACLE_CYLINDER: ObstacleType = 0;
    pub const ObstacleType_DT_OBSTACLE_BOX: ObstacleType = 1;
    pub const ObstacleType_DT_OBSTACLE_ORIENTED_BOX: ObstacleType = 2;
    pub type ObstacleType = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtObstacleCylinder {
        pub pos: [f32; 3usize],
        pub radius: f32,
        pub height: f32,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtObstacleCylinder"][::std::mem::size_of::<dtObstacleCylinder>() - 20usize];
        ["Alignment of dtObstacleCylinder"][::std::mem::align_of::<dtObstacleCylinder>() - 4usize];
        ["Offset of field: dtObstacleCylinder::pos"]
            [::std::mem::offset_of!(dtObstacleCylinder, pos) - 0usize];
        ["Offset of field: dtObstacleCylinder::radius"]
            [::std::mem::offset_of!(dtObstacleCylinder, radius) - 12usize];
        ["Offset of field: dtObstacleCylinder::height"]
            [::std::mem::offset_of!(dtObstacleCylinder, height) - 16usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtObstacleBox {
        pub bmin: [f32; 3usize],
        pub bmax: [f32; 3usize],
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtObstacleBox"][::std::mem::size_of::<dtObstacleBox>() - 24usize];
        ["Alignment of dtObstacleBox"][::std::mem::align_of::<dtObstacleBox>() - 4usize];
        ["Offset of field: dtObstacleBox::bmin"]
            [::std::mem::offset_of!(dtObstacleBox, bmin) - 0usize];
        ["Offset of field: dtObstacleBox::bmax"]
            [::std::mem::offset_of!(dtObstacleBox, bmax) - 12usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtObstacleOrientedBox {
        pub center: [f32; 3usize],
        pub halfExtents: [f32; 3usize],
        pub rotAux: [f32; 2usize],
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtObstacleOrientedBox"][::std::mem::size_of::<dtObstacleOrientedBox>() - 32usize];
        ["Alignment of dtObstacleOrientedBox"]
            [::std::mem::align_of::<dtObstacleOrientedBox>() - 4usize];
        ["Offset of field: dtObstacleOrientedBox::center"]
            [::std::mem::offset_of!(dtObstacleOrientedBox, center) - 0usize];
        ["Offset of field: dtObstacleOrientedBox::halfExtents"]
            [::std::mem::offset_of!(dtObstacleOrientedBox, halfExtents) - 12usize];
        ["Offset of field: dtObstacleOrientedBox::rotAux"]
            [::std::mem::offset_of!(dtObstacleOrientedBox, rotAux) - 24usize];
    };
    pub const DT_MAX_TOUCHED_TILES: ::std::os::raw::c_int = 8;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct dtTileCacheObstacle {
        pub __bindgen_anon_1: root::dtTileCacheObstacle__bindgen_ty_1,
        pub touched: [root::dtCompressedTileRef; 8usize],
        pub pending: [root::dtCompressedTileRef; 8usize],
        pub salt: ::std::os::raw::c_ushort,
        pub type_: ::std::os::raw::c_uchar,
        pub state: ::std::os::raw::c_uchar,
        pub ntouched: ::std::os::raw::c_uchar,
        pub npending: ::std::os::raw::c_uchar,
        pub next: *mut root::dtTileCacheObstacle,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union dtTileCacheObstacle__bindgen_ty_1 {
        pub cylinder: root::dtObstacleCylinder,
        pub box_: root::dtObstacleBox,
        pub orientedBox: root::dtObstacleOrientedBox,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtTileCacheObstacle__bindgen_ty_1"]
            [::std::mem::size_of::<dtTileCacheObstacle__bindgen_ty_1>() - 32usize];
        ["Alignment of dtTileCacheObstacle__bindgen_ty_1"]
            [::std::mem::align_of::<dtTileCacheObstacle__bindgen_ty_1>() - 4usize];
        ["Offset of field: dtTileCacheObstacle__bindgen_ty_1::cylinder"]
            [::std::mem::offset_of!(dtTileCacheObstacle__bindgen_ty_1, cylinder) - 0usize];
        ["Offset of field: dtTileCacheObstacle__bindgen_ty_1::box_"]
            [::std::mem::offset_of!(dtTileCacheObstacle__bindgen_ty_1, box_) - 0usize];
        ["Offset of field: dtTileCacheObstacle__bindgen_ty_1::orientedBox"]
            [::std::mem::offset_of!(dtTileCacheObstacle__bindgen_ty_1, orientedBox) - 0usize];
    };
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtTileCacheObstacle"][::std::mem::size_of::<dtTileCacheObstacle>() - 112usize];
        ["Alignment of dtTileCacheObstacle"]
            [::std::mem::align_of::<dtTileCacheObstacle>() - 8usize];
        ["Offset of field: dtTileCacheObstacle::touched"]
            [::std::mem::offset_of!(dtTileCacheObstacle, touched) - 32usize];
        ["Offset of field: dtTileCacheObstacle::pending"]
            [::std::mem::offset_of!(dtTileCacheObstacle, pending) - 64usize];
        ["Offset of field: dtTileCacheObstacle::salt"]
            [::std::mem::offset_of!(dtTileCacheObstacle, salt) - 96usize];
        ["Offset of field: dtTileCacheObstacle::type_"]
            [::std::mem::offset_of!(dtTileCacheObstacle, type_) - 98usize];
        ["Offset of field: dtTileCacheObstacle::state"]
            [::std::mem::offset_of!(dtTileCacheObstacle, state) - 99usize];
        ["Offset of field: dtTileCacheObstacle::ntouched"]
            [::std::mem::offset_of!(dtTileCacheObstacle, ntouched) - 100usize];
        ["Offset of field: dtTileCacheObstacle::npending"]
            [::std::mem::offset_of!(dtTileCacheObstacle, npending) - 101usize];
        ["Offset of field: dtTileCacheObstacle::next"]
            [::std::mem::offset_of!(dtTileCacheObstacle, next) - 104usize];
    };
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtTileCacheParams {
        pub orig: [f32; 3usize],
        pub cs: f32,
        pub ch: f32,
        pub width: ::std::os::raw::c_int,
        pub height: ::std::os::raw::c_int,
        pub walkableHeight: f32,
        pub walkableRadius: f32,
        pub walkableClimb: f32,
        pub maxSimplificationError: f32,
        pub maxTiles: ::std::os::raw::c_int,
        pub maxObstacles: ::std::os::raw::c_int,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtTileCacheParams"][::std::mem::size_of::<dtTileCacheParams>() - 52usize];
        ["Alignment of dtTileCacheParams"][::std::mem::align_of::<dtTileCacheParams>() - 4usize];
        ["Offset of field: dtTileCacheParams::orig"]
            [::std::mem::offset_of!(dtTileCacheParams, orig) - 0usize];
        ["Offset of field: dtTileCacheParams::cs"]
            [::std::mem::offset_of!(dtTileCacheParams, cs) - 12usize];
        ["Offset of field: dtTileCacheParams::ch"]
            [::std::mem::offset_of!(dtTileCacheParams, ch) - 16usize];
        ["Offset of field: dtTileCacheParams::width"]
            [::std::mem::offset_of!(dtTileCacheParams, width) - 20usize];
        ["Offset of field: dtTileCacheParams::height"]
            [::std::mem::offset_of!(dtTileCacheParams, height) - 24usize];
        ["Offset of field: dtTileCacheParams::walkableHeight"]
            [::std::mem::offset_of!(dtTileCacheParams, walkableHeight) - 28usize];
        ["Offset of field: dtTileCacheParams::walkableRadius"]
            [::std::mem::offset_of!(dtTileCacheParams, walkableRadius) - 32usize];
        ["Offset of field: dtTileCacheParams::walkableClimb"]
            [::std::mem::offset_of!(dtTileCacheParams, walkableClimb) - 36usize];
        ["Offset of field: dtTileCacheParams::maxSimplificationError"]
            [::std::mem::offset_of!(dtTileCacheParams, maxSimplificationError) - 40usize];
        ["Offset of field: dtTileCacheParams::maxTiles"]
            [::std::mem::offset_of!(dtTileCacheParams, maxTiles) - 44usize];
        ["Offset of field: dtTileCacheParams::maxObstacles"]
            [::std::mem::offset_of!(dtTileCacheParams, maxObstacles) - 48usize];
    };
    #[repr(C)]
    pub struct dtTileCacheMeshProcess__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtTileCacheMeshProcess {
        pub vtable_: *const dtTileCacheMeshProcess__bindgen_vtable,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtTileCacheMeshProcess"]
            [::std::mem::size_of::<dtTileCacheMeshProcess>() - 8usize];
        ["Alignment of dtTileCacheMeshProcess"]
            [::std::mem::align_of::<dtTileCacheMeshProcess>() - 8usize];
    };
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtTileCacheMeshProcess@@UEAA@XZ"]
        pub fn dtTileCacheMeshProcess_dtTileCacheMeshProcess_destructor(
            this: *mut root::dtTileCacheMeshProcess,
        );
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct dtTileCache {
        #[doc = "< Tile hash lookup size (must be pot)."]
        pub m_tileLutSize: ::std::os::raw::c_int,
        #[doc = "< Tile hash lookup mask."]
        pub m_tileLutMask: ::std::os::raw::c_int,
        #[doc = "< Tile hash lookup."]
        pub m_posLookup: *mut *mut root::dtCompressedTile,
        #[doc = "< Freelist of tiles."]
        pub m_nextFreeTile: *mut root::dtCompressedTile,
        #[doc = "< List of tiles."]
        pub m_tiles: *mut root::dtCompressedTile,
        #[doc = "< Number of salt bits in the tile ID."]
        pub m_saltBits: ::std::os::raw::c_uint,
        #[doc = "< Number of tile bits in the tile ID."]
        pub m_tileBits: ::std::os::raw::c_uint,
        pub m_params: root::dtTileCacheParams,
        pub m_talloc: *mut root::dtTileCacheAlloc,
        pub m_tcomp: *mut root::dtTileCacheCompressor,
        pub m_tmproc: *mut root::dtTileCacheMeshProcess,
        pub m_obstacles: *mut root::dtTileCacheObstacle,
        pub m_nextFreeObstacle: *mut root::dtTileCacheObstacle,
        pub m_reqs: [root::dtTileCache_ObstacleRequest; 64usize],
        pub m_nreqs: ::std::os::raw::c_int,
        pub m_update: [root::dtCompressedTileRef; 64usize],
        pub m_nupdate: ::std::os::raw::c_int,
    }
    pub const dtTileCache_ObstacleRequestAction_REQUEST_ADD: dtTileCache_ObstacleRequestAction = 0;
    pub const dtTileCache_ObstacleRequestAction_REQUEST_REMOVE: dtTileCache_ObstacleRequestAction =
        1;
    pub type dtTileCache_ObstacleRequestAction = ::std::os::raw::c_int;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtTileCache_ObstacleRequest {
        pub action: ::std::os::raw::c_int,
        pub ref_: root::dtObstacleRef,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtTileCache_ObstacleRequest"]
            [::std::mem::size_of::<dtTileCache_ObstacleRequest>() - 8usize];
        ["Alignment of dtTileCache_ObstacleRequest"]
            [::std::mem::align_of::<dtTileCache_ObstacleRequest>() - 4usize];
        ["Offset of field: dtTileCache_ObstacleRequest::action"]
            [::std::mem::offset_of!(dtTileCache_ObstacleRequest, action) - 0usize];
        ["Offset of field: dtTileCache_ObstacleRequest::ref_"]
            [::std::mem::offset_of!(dtTileCache_ObstacleRequest, ref_) - 4usize];
    };
    pub const dtTileCache_MAX_REQUESTS: ::std::os::raw::c_int = 64;
    pub const dtTileCache_MAX_UPDATE: ::std::os::raw::c_int = 64;
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of dtTileCache"][::std::mem::size_of::<dtTileCache>() - 912usize];
        ["Alignment of dtTileCache"][::std::mem::align_of::<dtTileCache>() - 8usize];
        ["Offset of field: dtTileCache::m_tileLutSize"]
            [::std::mem::offset_of!(dtTileCache, m_tileLutSize) - 0usize];
        ["Offset of field: dtTileCache::m_tileLutMask"]
            [::std::mem::offset_of!(dtTileCache, m_tileLutMask) - 4usize];
        ["Offset of field: dtTileCache::m_posLookup"]
            [::std::mem::offset_of!(dtTileCache, m_posLookup) - 8usize];
        ["Offset of field: dtTileCache::m_nextFreeTile"]
            [::std::mem::offset_of!(dtTileCache, m_nextFreeTile) - 16usize];
        ["Offset of field: dtTileCache::m_tiles"]
            [::std::mem::offset_of!(dtTileCache, m_tiles) - 24usize];
        ["Offset of field: dtTileCache::m_saltBits"]
            [::std::mem::offset_of!(dtTileCache, m_saltBits) - 32usize];
        ["Offset of field: dtTileCache::m_tileBits"]
            [::std::mem::offset_of!(dtTileCache, m_tileBits) - 36usize];
        ["Offset of field: dtTileCache::m_params"]
            [::std::mem::offset_of!(dtTileCache, m_params) - 40usize];
        ["Offset of field: dtTileCache::m_talloc"]
            [::std::mem::offset_of!(dtTileCache, m_talloc) - 96usize];
        ["Offset of field: dtTileCache::m_tcomp"]
            [::std::mem::offset_of!(dtTileCache, m_tcomp) - 104usize];
        ["Offset of field: dtTileCache::m_tmproc"]
            [::std::mem::offset_of!(dtTileCache, m_tmproc) - 112usize];
        ["Offset of field: dtTileCache::m_obstacles"]
            [::std::mem::offset_of!(dtTileCache, m_obstacles) - 120usize];
        ["Offset of field: dtTileCache::m_nextFreeObstacle"]
            [::std::mem::offset_of!(dtTileCache, m_nextFreeObstacle) - 128usize];
        ["Offset of field: dtTileCache::m_reqs"]
            [::std::mem::offset_of!(dtTileCache, m_reqs) - 136usize];
        ["Offset of field: dtTileCache::m_nreqs"]
            [::std::mem::offset_of!(dtTileCache, m_nreqs) - 648usize];
        ["Offset of field: dtTileCache::m_update"]
            [::std::mem::offset_of!(dtTileCache, m_update) - 652usize];
        ["Offset of field: dtTileCache::m_nupdate"]
            [::std::mem::offset_of!(dtTileCache, m_nupdate) - 908usize];
    };
    unsafe extern "C" {
        #[link_name = "\u{1}?getObstacleByRef@dtTileCache@@QEAAPEBUdtTileCacheObstacle@@I@Z"]
        pub fn dtTileCache_getObstacleByRef(
            this: *mut root::dtTileCache,
            ref_: root::dtObstacleRef,
        ) -> *const root::dtTileCacheObstacle;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?getObstacleRef@dtTileCache@@QEBAIPEBUdtTileCacheObstacle@@@Z"]
        pub fn dtTileCache_getObstacleRef(
            this: *const root::dtTileCache,
            obmin: *const root::dtTileCacheObstacle,
        ) -> root::dtObstacleRef;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?init@dtTileCache@@QEAAIPEBUdtTileCacheParams@@PEAUdtTileCacheAlloc@@PEAUdtTileCacheCompressor@@PEAUdtTileCacheMeshProcess@@@Z"]
        pub fn dtTileCache_init(
            this: *mut root::dtTileCache,
            params: *const root::dtTileCacheParams,
            talloc: *mut root::dtTileCacheAlloc,
            tcomp: *mut root::dtTileCacheCompressor,
            tmproc: *mut root::dtTileCacheMeshProcess,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?getTilesAt@dtTileCache@@QEBAHHHPEAIH@Z"]
        pub fn dtTileCache_getTilesAt(
            this: *const root::dtTileCache,
            tx: ::std::os::raw::c_int,
            ty: ::std::os::raw::c_int,
            tiles: *mut root::dtCompressedTileRef,
            maxTiles: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?getTileAt@dtTileCache@@QEAAPEAUdtCompressedTile@@HHH@Z"]
        pub fn dtTileCache_getTileAt(
            this: *mut root::dtTileCache,
            tx: ::std::os::raw::c_int,
            ty: ::std::os::raw::c_int,
            tlayer: ::std::os::raw::c_int,
        ) -> *mut root::dtCompressedTile;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?getTileRef@dtTileCache@@QEBAIPEBUdtCompressedTile@@@Z"]
        pub fn dtTileCache_getTileRef(
            this: *const root::dtTileCache,
            tile: *const root::dtCompressedTile,
        ) -> root::dtCompressedTileRef;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?getTileByRef@dtTileCache@@QEBAPEBUdtCompressedTile@@I@Z"]
        pub fn dtTileCache_getTileByRef(
            this: *const root::dtTileCache,
            ref_: root::dtCompressedTileRef,
        ) -> *const root::dtCompressedTile;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?addTile@dtTileCache@@QEAAIPEAEHEPEAI@Z"]
        pub fn dtTileCache_addTile(
            this: *mut root::dtTileCache,
            data: *mut ::std::os::raw::c_uchar,
            dataSize: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_uchar,
            result: *mut root::dtCompressedTileRef,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?removeTile@dtTileCache@@QEAAIIPEAPEAEPEAH@Z"]
        pub fn dtTileCache_removeTile(
            this: *mut root::dtTileCache,
            ref_: root::dtCompressedTileRef,
            data: *mut *mut ::std::os::raw::c_uchar,
            dataSize: *mut ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?addObstacle@dtTileCache@@QEAAIPEBMMMPEAI@Z"]
        pub fn dtTileCache_addObstacle(
            this: *mut root::dtTileCache,
            pos: *const f32,
            radius: f32,
            height: f32,
            result: *mut root::dtObstacleRef,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?addBoxObstacle@dtTileCache@@QEAAIPEBM0PEAI@Z"]
        pub fn dtTileCache_addBoxObstacle(
            this: *mut root::dtTileCache,
            bmin: *const f32,
            bmax: *const f32,
            result: *mut root::dtObstacleRef,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?addBoxObstacle@dtTileCache@@QEAAIPEBM0MPEAI@Z"]
        pub fn dtTileCache_addBoxObstacle1(
            this: *mut root::dtTileCache,
            center: *const f32,
            halfExtents: *const f32,
            yRadians: f32,
            result: *mut root::dtObstacleRef,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?removeObstacle@dtTileCache@@QEAAII@Z"]
        pub fn dtTileCache_removeObstacle(
            this: *mut root::dtTileCache,
            ref_: root::dtObstacleRef,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?queryTiles@dtTileCache@@QEBAIPEBM0PEAIPEAHH@Z"]
        pub fn dtTileCache_queryTiles(
            this: *const root::dtTileCache,
            bmin: *const f32,
            bmax: *const f32,
            results: *mut root::dtCompressedTileRef,
            resultCount: *mut ::std::os::raw::c_int,
            maxResults: ::std::os::raw::c_int,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[doc = " Updates the tile cache by rebuilding tiles touched by unfinished obstacle requests.\n  @param[in]\t\tdt\t\t\tThe time step size. Currently not used.\n  @param[in]\t\tnavmesh\t\tThe mesh to affect when rebuilding tiles.\n  @param[out]\tupToDate\tWhether the tile cache is fully up to date with obstacle requests and tile rebuilds.\n  \t\t\t\t\t\t\tIf the tile cache is up to date another (immediate) call to update will have no effect;\n  \t\t\t\t\t\t\totherwise another call will continue processing obstacle requests and tile rebuilds."]
        #[link_name = "\u{1}?update@dtTileCache@@QEAAIMPEAVdtNavMesh@@PEA_N@Z"]
        pub fn dtTileCache_update(
            this: *mut root::dtTileCache,
            dt: f32,
            navmesh: *mut root::dtNavMesh,
            upToDate: *mut bool,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?buildNavMeshTilesAt@dtTileCache@@QEAAIHHPEAVdtNavMesh@@@Z"]
        pub fn dtTileCache_buildNavMeshTilesAt(
            this: *mut root::dtTileCache,
            tx: ::std::os::raw::c_int,
            ty: ::std::os::raw::c_int,
            navmesh: *mut root::dtNavMesh,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?buildNavMeshTile@dtTileCache@@QEAAIIPEAVdtNavMesh@@@Z"]
        pub fn dtTileCache_buildNavMeshTile(
            this: *mut root::dtTileCache,
            ref_: root::dtCompressedTileRef,
            navmesh: *mut root::dtNavMesh,
        ) -> root::dtStatus;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?calcTightTileBounds@dtTileCache@@QEBAXPEBUdtTileCacheLayerHeader@@PEAM1@Z"]
        pub fn dtTileCache_calcTightTileBounds(
            this: *const root::dtTileCache,
            header: *const root::dtTileCacheLayerHeader,
            bmin: *mut f32,
            bmax: *mut f32,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?getObstacleBounds@dtTileCache@@QEBAXPEBUdtTileCacheObstacle@@PEAM1@Z"]
        pub fn dtTileCache_getObstacleBounds(
            this: *const root::dtTileCache,
            ob: *const root::dtTileCacheObstacle,
            bmin: *mut f32,
            bmax: *mut f32,
        );
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??0dtTileCache@@QEAA@XZ"]
        pub fn dtTileCache_dtTileCache(this: *mut root::dtTileCache);
    }
    unsafe extern "C" {
        #[link_name = "\u{1}??1dtTileCache@@QEAA@XZ"]
        pub fn dtTileCache_dtTileCache_destructor(this: *mut root::dtTileCache);
    }
    impl dtTileCache {
        #[inline]
        pub unsafe fn getObstacleByRef(
            &mut self,
            ref_: root::dtObstacleRef,
        ) -> *const root::dtTileCacheObstacle {
            dtTileCache_getObstacleByRef(self, ref_)
        }
        #[inline]
        pub unsafe fn getObstacleRef(
            &self,
            obmin: *const root::dtTileCacheObstacle,
        ) -> root::dtObstacleRef {
            dtTileCache_getObstacleRef(self, obmin)
        }
        #[inline]
        pub unsafe fn init(
            &mut self,
            params: *const root::dtTileCacheParams,
            talloc: *mut root::dtTileCacheAlloc,
            tcomp: *mut root::dtTileCacheCompressor,
            tmproc: *mut root::dtTileCacheMeshProcess,
        ) -> root::dtStatus {
            dtTileCache_init(self, params, talloc, tcomp, tmproc)
        }
        #[inline]
        pub unsafe fn getTilesAt(
            &self,
            tx: ::std::os::raw::c_int,
            ty: ::std::os::raw::c_int,
            tiles: *mut root::dtCompressedTileRef,
            maxTiles: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int {
            dtTileCache_getTilesAt(self, tx, ty, tiles, maxTiles)
        }
        #[inline]
        pub unsafe fn getTileAt(
            &mut self,
            tx: ::std::os::raw::c_int,
            ty: ::std::os::raw::c_int,
            tlayer: ::std::os::raw::c_int,
        ) -> *mut root::dtCompressedTile {
            dtTileCache_getTileAt(self, tx, ty, tlayer)
        }
        #[inline]
        pub unsafe fn getTileRef(
            &self,
            tile: *const root::dtCompressedTile,
        ) -> root::dtCompressedTileRef {
            dtTileCache_getTileRef(self, tile)
        }
        #[inline]
        pub unsafe fn getTileByRef(
            &self,
            ref_: root::dtCompressedTileRef,
        ) -> *const root::dtCompressedTile {
            dtTileCache_getTileByRef(self, ref_)
        }
        #[inline]
        pub unsafe fn addTile(
            &mut self,
            data: *mut ::std::os::raw::c_uchar,
            dataSize: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_uchar,
            result: *mut root::dtCompressedTileRef,
        ) -> root::dtStatus {
            dtTileCache_addTile(self, data, dataSize, flags, result)
        }
        #[inline]
        pub unsafe fn removeTile(
            &mut self,
            ref_: root::dtCompressedTileRef,
            data: *mut *mut ::std::os::raw::c_uchar,
            dataSize: *mut ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtTileCache_removeTile(self, ref_, data, dataSize)
        }
        #[inline]
        pub unsafe fn addObstacle(
            &mut self,
            pos: *const f32,
            radius: f32,
            height: f32,
            result: *mut root::dtObstacleRef,
        ) -> root::dtStatus {
            dtTileCache_addObstacle(self, pos, radius, height, result)
        }
        #[inline]
        pub unsafe fn addBoxObstacle(
            &mut self,
            bmin: *const f32,
            bmax: *const f32,
            result: *mut root::dtObstacleRef,
        ) -> root::dtStatus {
            dtTileCache_addBoxObstacle(self, bmin, bmax, result)
        }
        #[inline]
        pub unsafe fn addBoxObstacle1(
            &mut self,
            center: *const f32,
            halfExtents: *const f32,
            yRadians: f32,
            result: *mut root::dtObstacleRef,
        ) -> root::dtStatus {
            dtTileCache_addBoxObstacle1(self, center, halfExtents, yRadians, result)
        }
        #[inline]
        pub unsafe fn removeObstacle(&mut self, ref_: root::dtObstacleRef) -> root::dtStatus {
            dtTileCache_removeObstacle(self, ref_)
        }
        #[inline]
        pub unsafe fn queryTiles(
            &self,
            bmin: *const f32,
            bmax: *const f32,
            results: *mut root::dtCompressedTileRef,
            resultCount: *mut ::std::os::raw::c_int,
            maxResults: ::std::os::raw::c_int,
        ) -> root::dtStatus {
            dtTileCache_queryTiles(self, bmin, bmax, results, resultCount, maxResults)
        }
        #[inline]
        pub unsafe fn update(
            &mut self,
            dt: f32,
            navmesh: *mut root::dtNavMesh,
            upToDate: *mut bool,
        ) -> root::dtStatus {
            dtTileCache_update(self, dt, navmesh, upToDate)
        }
        #[inline]
        pub unsafe fn buildNavMeshTilesAt(
            &mut self,
            tx: ::std::os::raw::c_int,
            ty: ::std::os::raw::c_int,
            navmesh: *mut root::dtNavMesh,
        ) -> root::dtStatus {
            dtTileCache_buildNavMeshTilesAt(self, tx, ty, navmesh)
        }
        #[inline]
        pub unsafe fn buildNavMeshTile(
            &mut self,
            ref_: root::dtCompressedTileRef,
            navmesh: *mut root::dtNavMesh,
        ) -> root::dtStatus {
            dtTileCache_buildNavMeshTile(self, ref_, navmesh)
        }
        #[inline]
        pub unsafe fn calcTightTileBounds(
            &self,
            header: *const root::dtTileCacheLayerHeader,
            bmin: *mut f32,
            bmax: *mut f32,
        ) {
            dtTileCache_calcTightTileBounds(self, header, bmin, bmax)
        }
        #[inline]
        pub unsafe fn getObstacleBounds(
            &self,
            ob: *const root::dtTileCacheObstacle,
            bmin: *mut f32,
            bmax: *mut f32,
        ) {
            dtTileCache_getObstacleBounds(self, ob, bmin, bmax)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            dtTileCache_dtTileCache(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            dtTileCache_dtTileCache_destructor(self)
        }
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtAllocTileCache@@YAPEAVdtTileCache@@XZ"]
        pub fn dtAllocTileCache() -> *mut root::dtTileCache;
    }
    unsafe extern "C" {
        #[link_name = "\u{1}?dtFreeTileCache@@YAXPEAVdtTileCache@@@Z"]
        pub fn dtFreeTileCache(tc: *mut root::dtTileCache);
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct rcChunkyTriMeshNode {
        pub bmin: [f32; 2usize],
        pub bmax: [f32; 2usize],
        pub i: ::std::os::raw::c_int,
        pub n: ::std::os::raw::c_int,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of rcChunkyTriMeshNode"][::std::mem::size_of::<rcChunkyTriMeshNode>() - 24usize];
        ["Alignment of rcChunkyTriMeshNode"]
            [::std::mem::align_of::<rcChunkyTriMeshNode>() - 4usize];
        ["Offset of field: rcChunkyTriMeshNode::bmin"]
            [::std::mem::offset_of!(rcChunkyTriMeshNode, bmin) - 0usize];
        ["Offset of field: rcChunkyTriMeshNode::bmax"]
            [::std::mem::offset_of!(rcChunkyTriMeshNode, bmax) - 8usize];
        ["Offset of field: rcChunkyTriMeshNode::i"]
            [::std::mem::offset_of!(rcChunkyTriMeshNode, i) - 16usize];
        ["Offset of field: rcChunkyTriMeshNode::n"]
            [::std::mem::offset_of!(rcChunkyTriMeshNode, n) - 20usize];
    };
    #[repr(C)]
    #[derive(Debug)]
    pub struct rcChunkyTriMesh {
        pub nodes: *mut root::rcChunkyTriMeshNode,
        pub nnodes: ::std::os::raw::c_int,
        pub tris: *mut ::std::os::raw::c_int,
        pub ntris: ::std::os::raw::c_int,
        pub maxTrisPerChunk: ::std::os::raw::c_int,
    }
    #[allow(clippy::unnecessary_operation, clippy::identity_op)]
    const _: () = {
        ["Size of rcChunkyTriMesh"][::std::mem::size_of::<rcChunkyTriMesh>() - 32usize];
        ["Alignment of rcChunkyTriMesh"][::std::mem::align_of::<rcChunkyTriMesh>() - 8usize];
        ["Offset of field: rcChunkyTriMesh::nodes"]
            [::std::mem::offset_of!(rcChunkyTriMesh, nodes) - 0usize];
        ["Offset of field: rcChunkyTriMesh::nnodes"]
            [::std::mem::offset_of!(rcChunkyTriMesh, nnodes) - 8usize];
        ["Offset of field: rcChunkyTriMesh::tris"]
            [::std::mem::offset_of!(rcChunkyTriMesh, tris) - 16usize];
        ["Offset of field: rcChunkyTriMesh::ntris"]
            [::std::mem::offset_of!(rcChunkyTriMesh, ntris) - 24usize];
        ["Offset of field: rcChunkyTriMesh::maxTrisPerChunk"]
            [::std::mem::offset_of!(rcChunkyTriMesh, maxTrisPerChunk) - 28usize];
    };
    unsafe extern "C" {
        #[doc = " Creates partitioned triangle mesh (AABB tree),\n where each node contains at max trisPerChunk triangles."]
        #[link_name = "\u{1}?rcCreateChunkyTriMesh@@YA_NPEBMPEBHHHPEAUrcChunkyTriMesh@@@Z"]
        pub fn rcCreateChunkyTriMesh(
            verts: *const f32,
            tris: *const ::std::os::raw::c_int,
            ntris: ::std::os::raw::c_int,
            trisPerChunk: ::std::os::raw::c_int,
            cm: *mut root::rcChunkyTriMesh,
        ) -> bool;
    }
    unsafe extern "C" {
        #[doc = " Returns the chunk indices which overlap the input rectable."]
        #[link_name = "\u{1}?rcGetChunksOverlappingRect@@YAHPEBUrcChunkyTriMesh@@QEAM1PEAHH@Z"]
        pub fn rcGetChunksOverlappingRect(
            cm: *const root::rcChunkyTriMesh,
            bmin: *mut f32,
            bmax: *mut f32,
            ids: *mut ::std::os::raw::c_int,
            maxIds: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    unsafe extern "C" {
        #[doc = " Returns the chunk indices which overlap the input segment."]
        #[link_name = "\u{1}?rcGetChunksOverlappingSegment@@YAHPEBUrcChunkyTriMesh@@QEAM1PEAHH@Z"]
        pub fn rcGetChunksOverlappingSegment(
            cm: *const root::rcChunkyTriMesh,
            p: *mut f32,
            q: *mut f32,
            ids: *mut ::std::os::raw::c_int,
            maxIds: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int;
    }
    #[doc = " Gets the node pool.\n @returns The node pool."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtNodePool {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtNode {
        _unused: [u8; 0],
    }
    #[doc = "< Pointer to open list queue."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtNodeQueue {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtTileCacheLayerHeader {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtTileCacheAlloc {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct dtTileCacheCompressor {
        pub _address: u8,
    }
}
